<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>The Little Book on CoffeeScript - Introduction</title>
<link rel="stylesheet" href="site/site.css" type="text/css" charset="utf-8">
<link rel="stylesheet" href="site/highlight.css" type="text/css" charset="utf-8">
<script src="site/jquery.js" type="text/javascript" charset="utf-8"></script>      
<script src="site/highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="site/coffee-script.js" type="text/javascript" charset="utf-8"></script>
<script src="site/preview.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
  hljs.initHighlightingOnLoad();
</script>
</head>
<body>
<div id="container">
  <header>
    <h1><a href="index.html">The Little Book on CoffeeScript</a></h1>
  </header>
  
  <div id="content">
    <div class="back"><a href="index.html">&laquo; 回到章节列表</a></div>


<h1>什么是CoffeeScript?</h1>

<p><a href="http://coffeescript.org">CoffeeScript</a> 是一门可以被编译成JavaScript的小型语言. 它借鉴了Ruby和Python的语法, 并借鉴了它们的一些特性. 本书致力于帮你学习CoffeeScript, 理解他的最佳实践并能够制作优质的客户端程序. 这本书很短小,只有五章, 但这也正好映衬了CoffeeScript这门短小的语言.</p>

<p>本书是完全开源的, 由 <a href="http://alexmaccaw.co.uk">Alex MacCaw</a> (or <a href="http://twitter.com/maccman">@maccman</a>) 编写并得到了 <a href="https://github.com/dxgriffiths">David Griffiths</a>, <a href="http://github.com/satyr">Satoshi Murakami</a>和 <a href="https://github.com/jashkenas">Jeremy Ashkenas</a>的支持.</p>

<p>如果你有建议或者发现书写错误, 别犹豫，在本书的<a href="https://github.com/arcturo/library">GitHub page</a>发起一个issue. 读者们可以也会对<a href="http://oreilly.com/catalog/9781449307530/">JavaScript Web Applications by O'Reilly</a>这本书比较感兴趣, 这是我写的一本介绍JavaScript富应用和客户端状态管理的书.</p>

<p>那我们现在就开始吧; 为什么写CoffeeScript会优于写纯JavaScript? 首先, 你可一些更少的代码 - CoffeeScript语法非常的精简明了, 并且把空格也当作了语法的一部分. 从我自己的经验来说，它相比纯JavaScript至少减少了三分之一到一半的代码. 并且, CoffeeScript拥有一些整洁的特性, 例如array comprehensions, prototype aliases 以及 减少了你代码量的类编写.</p>

<p>更重要的是, JavaScript的一些<a href="http://bonsaiden.github.com/JavaScript-Garden/">古怪的特性</a>经常会困扰一些经验不足的程序员. CoffeeScript巧妙的避开了这些问题，而只暴露JavaScript中发挥真正作用的那部分, 如此解决了这门语言中许多的问题.</p>

<p>CoffeeScript <em>不是</em> JavaScript 的子集, 因此虽然你可以在CoffeeScript中使用外部库而没有做对应的转换, 你在把它编译成JavaScript的时候还是会报错. 编译器会静态的把CoffeeScript的代码翻译成它自己对应的JavaScript副本, 而不是在代码运行期进行转换.</p>

<p>学习前我们先来看看一些常见的谬误. 在写 CoffeeScript 之前你需要了解 JavaScript, 因为运行期的错误需要你的JavaScript知识. 话说回来, 运行期的错误是非常明显的, 到目前为止我还没有觉得把JavaScript报错对应到CoffeeScript是一大麻烦事. 我听说过的第二个关于CoffeeScript的问题是运行速度; 举个例子. 通过 CoffeeScript 编译器生成的代码会比使用纯 JavaScript 编写的代码慢. 但是在实践中, 这并不是一个问题. CoffeeScript 跑得并不慢, 甚至于相比手写的 JavaScript 会更快.</p>

<p>那么使用 CoffeeScript 的劣势有哪些呢? 我想主要的就是它在你和JavaScript之间又增加一步编译. CoffeeScript 通过生成清晰可读的JavaScript代码以及通过服务端自动编译来尽可能的解决这个问题. 另一个劣势, 和别的新新语言一样, CoffeeScript的社区还是很小, 并且目前为止要找一个熟悉这么语言的同伴可能会很困难. 虽然如此CoffeeScript 还是在快速扩张并且它的IRC列表维护的很好; 你有任何的问题都可以得到及时的回应.</p>

<p>CoffeeScript 并不仅仅限于浏览器端的开发, 它在服务器端的JavaScript实现, 例如 <a href="http://nodejs.org/">Node.js</a>上面也有优异的表现. 此外, CoffeeScript正被广泛的使用和积累, 例如在 Rails 3.1 已经默认支持. 现在绝对是跳上CoffeeScript这趟快车的最佳时机. 现在学习这门语言投入的时间都将会在以后被偿还.</p>

<h2>初始化安装</h2>

<p>开始使用CoffeeScript最简单的方式就是在浏览器中使用它. 访问 <a href="http://coffeescript.org">http://coffeescript.org</a> 然后点击 <em>Try CoffeeScript</em> tab. 该站点使用了一个浏览器版本的CoffeeScript编译器，并且可以转换你在左侧面板输入的CoffeeScript到右侧的JavaScript面板中.</p>

<p>你也可以使用<a href="http://js2coffee.org/">js2coffee</a> 项目把JavaScript反转回CoffeeScript, 这在把JavaScript项目迁移至Coffee时非常有用.</p>

<p>事实上, 你可以通过引入<a href="http://jashkenas.github.com/coffee-script/extras/coffee-script.js">此脚本</a> 来使用这个工作于浏览器的CoffeeScript编译器, 并使用对应的 <code>type</code> 来标识 CoffeeScript脚本.</p>

<pre><code>&lt;script src="http://jashkenas.github.com/coffee-script/extras/coffee-script.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;
&lt;script type="text/coffeescript"&gt;
  # Some CoffeeScript
&lt;/script&gt;
</code></pre>

<p>不过，在实际的应用中，你显然不期望在运行期把CoffeeScript在客户端进行实时的解析.而CoffeeScript也正好提供了一个<a href="http://nodejs.org">Node.js</a>的编译器来预处理CoffeeScript文件.</p>

<p>要安装这个编译器, 首先要确保你安装了最新版本的 <a href="http://nodejs.org">Node.js</a>, 以及 <a href="http://npmjs.org/">npm</a> (Node包管理). 然后就可以使用npm来安装CoffeeScript:</p>

<pre><code>npm install -g coffee-script
</code></pre>

<p>通过加上 -g 可以是你直接使用<code>coffee</code>命令. 当你直接在命令行敲入这个命令，你将进入一个CoffeeScript的命令行模式,在里面可以输入并执行一些CoffeeScript语句. 如果要预处理CoffeeScript文件的话, 要在命令后面再加上 <code>--compile</code> 的选项.</p>

<pre><code>coffee --compile my-script.coffee
</code></pre>

<p>如果没有指定 <code>--output</code> 选项, CoffeeScript 编译器会生成一个和coffee文件同名的 JavaScript 文件, 在这个例子中就是 <code>my-script.js</code>. 如果有同名的js存在,则这个js会被覆盖, 因此要小心无意中覆盖了你原有的JavaScript文件. 如果要完整的了解命令行的各个选项，你需要加上一个 <code>--help</code> 选项.</p>

<p>正如你已经看到的，CoffeeScript文件默认的扩展名是<code>.coffee</code>. 这将可以使像<a href="http://macromates.com/">TextMate</a> 这样的编辑器使用合适的语法高亮来显示代码. 默认, TextMate 并不支持 CoffeeScript 语法, 但是你可以安装 <a href="https://github.com/jashkenas/coffee-script-tmbundle">插件</a> 来解决.</p>

<p>如果你觉得所有的编译过程看起来有些不方便, 那是因为它的确是这样的. 我们将通过自动编译CoffeeScript文件来解决这些问题, 不过首先让我们来看看CoffeeScript的语法.</p>

  </div>
</div>
</body>
</html><!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>The Little Book on CoffeeScript - Syntax</title>
<link rel="stylesheet" href="site/site.css" type="text/css" charset="utf-8">
<link rel="stylesheet" href="site/highlight.css" type="text/css" charset="utf-8">
<script src="site/jquery.js" type="text/javascript" charset="utf-8"></script>      
<script src="site/highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="site/coffee-script.js" type="text/javascript" charset="utf-8"></script>
<script src="site/preview.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
  hljs.initHighlightingOnLoad();
</script>
</head>
<body>
<div id="container">
  <header>
    <h1><a href="index.html">The Little Book on CoffeeScript</a></h1>
  </header>
  
  <div id="content">
    <div class="back"><a href="index.html">&laquo; 返回章节列表</a></div>


<h1>CoffeeScript 语法</h1>

<p>首先,在我们开始本章学习前,我还是要重申一下,CoffeeScript 和 JavaScript在语法上面是相对独立的，CoffeeScript不是JavaScript的子集, 因此一些JavaScript的关键字，如<code>function</code>、<code>var</code> 不是合法的,直接使用会导致抛错.如果你是在写CoffeeScript,那么它就应该是纯CoffeeScript,而不应该是两种语言的混合体.</p>

<p>为什么CoffeeScript不是一个子集合？一个很好的事实是在CoffeeScript中空格是有重要含义的. And, once that decision's been made, the team decided you might as well go the full hog and deprecate some JavaScript keywords and features in the name of simplicity and in an effort to reduce many commonly occurring bugs. 为了达到简洁并能够减少一些常见bug的出现，CoffeeScript的维护团队决定摒弃一些JavaScript的关键字和特性.（这句话感觉有些问题还）</p>

<p>让我兴奋的是，通过元排序的方式, CoffeeScript的编译器本身就是由CoffeeScript编写的. 这仿佛解决了一个鸡生蛋还是蛋生鸡的问题.</p>

<p>好, 我们首先来说明一下最基本的问题. 在CoffeeScript中没有分号,分号都会在编译后被自动的加上.分号的可以引起很多奇怪的<a href="http://bonsaiden.github.com/JavaScript-Garden/#core.semicolon">行为</a>，这些旺旺会在JavaScript社区引起了很多的争论.不管怎么说, CoffeeScript 在它的语法中去掉了分号而是在需要时再加上从而解决了这一系列问题.</p>

<p>CoffeeScript的注释是和Ruby的注释形式一样的, 在行首加上一个井号即可.</p>

<pre><code># A comment
</code></pre>

<p>多行的注释同样支持, 并且这些注释也会被带到编译后的js中. 注释的代码被三个井号的对所包围.</p>

<p><span class="csscript"></span></p>

<pre><code>###
  A multiline comment, perhaps a LICENSE.
###
</code></pre>

<p>正如我之前提到的, 空白在 CoffeeScript 中作用显著. 实际运用中, 你可以用一个制表符来代替块结构 (<code>{}</code>) . 这一点沿袭了Python的语法, 这样能够确保你的代码是以一种优良的方式被格式化显示, 否则，代码可能不能被编译!</p>

<h2>变量 和 作用域</h2>

<p>CoffeeScript 修正了 JavaScript 中最容易产生问题的一点, 全局变量. 在 JavaScript 中, 在申明变量是往往很容易遗漏 <code>var</code> 从而产生了全局变量. CoffeeScript 去掉了全局变量从而解决了这一问题. 事实上, CoffeeScript 通过一个匿名函数来包裹脚本, 保证了本地作用域, 并且会默认对所有的变量申明都加上 <code>var</code>. 举个例子, 就像这样一个 CoffeeScript 中的变量赋值:</p>

<p><span class="csscript"></span></p>

<pre><code>myVariable = "test"
</code></pre>

<p>注意到代码部分右上角的深灰色按钮了么？ 点击它, 代码会在CoffeeScript和编译后的JavaScript之间切换. 这些都是在页面中实时生成的, 你可以放心这些编译结果都是正确的.</p>

<p>可以看到, 赋值的变量作用域保持在了本地, 这也杜绝了产生全局变量的可能. CoffeeScript 还做了更进一步处理, 使得要覆盖高级别的变量变得更为困难. 这很好的避免了一些常见的JavaScript开发的错误=.</p>

<p>然而, 有时候创建全局变量是很有用的. 这时你可以在全局对象(如浏览器中的<code>window</code>)上面挂载变量或者使用以下的形式:</p>

<p><span class="csscript"></span></p>

<pre><code>exports = this
exports.MyVariable = "foo-bar"
</code></pre>

<p>在底层的上下文中，<code>this</code> 指向了全局对象, 通过创建一个叫 <code>exports</code> 的本地变量，你可以很明确的告诉别人脚本中的哪些变量是全局创建的. 并且, 他为 CommonJS 模块铺平了道路, 关于CommonJS我们将在后面讲述.</p>

<h2>函数</h2>

<p>CoffeeScript 相当累赘的 <code>function</code> 语句, 而用一个 <code>-&gt;</code> 来代替它. 函数申明可以是一行或者是多行. 最后的一个表达式会作为函数的返回结果. 换句话说, 你根本不需要 <code>return</code> 语句除非你是想在函数内更早的地方返回函数.</p>

<p>了解了这些, 我们来看一个例子:</p>

<p><span class="csscript"></span></p>

<pre><code>func = -&gt; "bar"
</code></pre>

<p>你可以发现在编译的结果中, <code>-&gt;</code> 被转化成了 <code>function</code> 语句, 并且字符串 <code>"bar"</code> 被自动作为结果返回了.</p>

<p>之前已经提到, 我们肯定会用到多行的函数申明, 只要我们正确地缩进.</p>

<p><span class="csscript"></span></p>

<pre><code>func = -&gt;
  # An extra line
  "bar"
</code></pre>

<h3>函数参数</h3>

<p>那么如何指定函数的参数呢? CoffeeScript 允许你在函数的箭头前面指定函数的参数.</p>

<p><span class="csscript"></span></p>

<pre><code>times = (a, b) -&gt; a * b
</code></pre>

<p>CoffeeScript 还支持参数的默认值, 例子:</p>

<p><span class="csscript"></span></p>

<pre><code>times = (a = 1, b = 2) -&gt; a * b
</code></pre>

<p>你也可以使用省略号 <code>...</code> 来允许接受多个参数</p>

<p><span class="csscript"></span></p>

<pre><code>sum = (nums...) -&gt; 
  result = 0
  nums.forEach (n) -&gt; result += n
  result
</code></pre>

<p>在上面的例子中, <code>nums</code> 作为一个包含所有参数的参数数组传递给函数. 它不是一个 <code>arguments</code> 对象, 而是一个真正的数组, 因此当你要操作它时, 你不需要 <code>Array.prototype.splice</code> 或是 <code>jQuery.makeArray()</code> 多做一次处理.</p>

<p><span class="csscript"></span></p>

<pre><code>trigger = (events...) -&gt;
  events.splice(1, 0, this)
  this.constructor.trigger.apply(events)
</code></pre>

<h3>函数调用</h3>

<p>在JavaScript中通过<code>()</code>, <code>apply()</code> 或者 <code>call()</code>可以调用函数. 而在CoffeeScript中, 则类似 Ruby, CoffeeScript 中如果函数传递了至少一个参数,那么他就会执行.</p>

<p><span class="csscript"></span></p>

<pre><code>a = "Howdy!"

alert a
# Equivalent to:
alert(a)

alert inspect a
# Equivalent to:
alert(inspect(a))
</code></pre>

<p>虽然括号在调用是可选的, 但我还是强烈建议加上，这样可以明显的区分哪些是函数以及他们的参数. 在最后的这个例子中, 对于函数 <code>inspect</code>, 我建议至少要在 <code>inspect</code> 外面包上括号.</p>

<p><span class="csscript"></span></p>

<pre><code>alert inspect(a)
</code></pre>

<p>如果在调用时你不传递任何的参数, CoffeeScript将没有办法区分你是要立即调用这个函数还是说把它作为一个变量. 在这方面, CoffeeScript的行为与 Ruby 就不一样了, Ruby总是会调用函数的引用, 而这更像是 Python 的语法. 这样子做确保了在 CoffeeScript 程序中不会轻易产生错误, 因此当你需要调用一个函数而不打算传参给它的时候记得要保留括号.</p>

<h3>函数上下文</h3>

<p>上下文的变化在JavaScript中是很频繁的一件事情, 尤其是在事件回调的时候,因此COffeeScript提供了一些辅助功能特性来解决这类问题. 一个特性是<code>-&gt;</code> 的变种 <code>=&gt;</code></p>

<p>使用 <code>=&gt;</code> 代替 <code>-&gt;</code> 可以保证函数的上下文会始终指向本地的上下文. 例如:</p>

<p><span class="csscript"></span></p>

<pre><code>this.clickHandler = -&gt; alert "clicked"
element.addEventListener "click", (e) =&gt; this.clickHandler(e)
</code></pre>

<p>你需要这么做的原因是,<code>addEventListener()</code> 的回调是在 <code>element</code> 的上下文中执行的, 即 <code>this</code> 指向 <code>element</code> . 如果你要保持 <code>this</code> 始终等于本地上下文, 并省略类似 <code>self = this</code> 这样的步骤, <code>=&gt;</code> 正好满足你的需求.</p>

<p>这种绑定的思想借鉴自jQuery的 <a href="http://api.jquery.com/jQuery.proxy/"><code>proxy()</code></a> 以及 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind">ES5's</a> <code>bind()</code> 函数.</p>

<h2>对象字面量 &amp; 数组定义</h2>

<p>在JavaScript中，可以通过一对包裹key/value的大括号来申明对象字面量. 然而, 正如对函数声明的改进, CoffeeScript 把大括号作为了可选的. 事实上, 你甚至可以使用缩进和换行的方式来替代逗号分隔.</p>

<p><span class="csscript"></span></p>

<pre><code>object1 = {one: 1, two: 2}

# Without braces
object2 = one: 1, two: 2

# Using new lines instead of commas
object3 = 
  one: 1
  two: 2

User.create(name: "John Smith")
</code></pre>

<p>类似地, 数组的逗号也可以用空格来替代, 不过中括号 (<code>[]</code>) 还是要保留的.</p>

<p><span class="csscript"></span></p>

<pre><code>array1 = [1, 2, 3]

array2 = [
  1
  2
  3
]

array3 = [1,2,3,]
</code></pre>

<p>从上面的例子你可以看到, CoffeeScript 会去掉 <code>array3</code>的最后一个逗号, 这也是经常会引起跨浏览器问题的一个原因.</p>

<h2>流控制</h2>

<p>在流控制语句中, CoffeeScript 把括号作为了可选, 但还是保留了<code>if</code> 和 <code>else</code>关键字.</p>

<p><span class="csscript"></span></p>

<pre><code>if true == true
  "We're ok"

if true != true then "Panic"

# Equivalent to:
#  (1 &gt; 0) ? "Ok" : "Y2K!"
if 1 &gt; 0 then "Ok" else "Y2K!"
</code></pre>

<p>从上面你可以发现, 如果 <code>if</code> 语句是单行的, 你还需要加上一个 <code>then</code> 关键字, 这样CoffeeScript可以知道语句块从何处开始. 要指出的是条件操作符 (<code>?:</code>) 并不被CoffeeScrit支持, 你可以使用单行 <code>if/else</code> 代替.</p>

<p>CoffeeScript 还在<code>if</code>语句中引入了一个Ruby的语法特性.</p>

<p><span class="csscript"></span></p>

<pre><code>alert "It's cold!" if heat &lt; 5
</code></pre>

<p>除了使用<code>!</code>来表示非, 你还可以使用<code>not</code> 关键字. 这也在某种程度上面增加了程序的可读性.</p>

<p><span class="csscript"></span></p>

<pre><code>if not true then "Panic"
</code></pre>

<p>在上面的例子中, 我们还可以使用 CoffeeScript的 <code>unless</code> 语句, 他的逻辑与 <code>if</code> 正好相反.</p>

<p><span class="csscript"></span></p>

<pre><code>unless true
  "Panic"
</code></pre>

<p>类似 <code>not</code>, CoffeeScript 还加上了 <code>is</code> 语句, 它等同于 <code>===</code>.</p>

<p><span class="csscript"></span></p>

<pre><code>if true is 1
  "Type coercion fail!"
</code></pre>

<p>此外, 如果要替代 <code>is not</code>, 你还可以使用 <code>isnt</code>.</p>

<pre><code>if true isnt true
  alert "Opposite day!"
</code></pre>

<p>你可能已经注意到上面的例子中, CoffeeScript 把 <code>==</code> 操作符转化为 <code>===</code> 同样把 <code>!=</code> 转化为 <code>!==</code>. 这是我个人最喜欢也是最简单的语言特性之一. 为什么要这么做呢? 老实说 JavaScript 的类型转换有点古怪, 要对比不同的变量必须要先经过类型转换, 这就可能会引起一些奇怪的问题或是bug. 这一块在第7章会有重点讨论.</p>

<h2>字符串插值</h2>

<p>CoffeeScript 把 Ruby 风格的字符串插值带到了 JavaScript中. 在双引号中可以包含 <code>#{}</code> 标签, 里面可以包含一些表达式的值被插入到字符串中.</p>

<p><span class="csscript"></span></p>

<pre><code>favourite_color = "Blue. No, yel..."
question = "Bridgekeeper: What... is your favourite color?
            Galahad: #{favourite_color}
            Bridgekeeper: Wrong!
            "
</code></pre>

<p>从上面的例子中你可以看出, 即使不加 <code>+</code> 号, 多行文本也是支持的.</p>

<h2>循环 和 Comprehensions（内含？）</h2>

<p>JavaScript中的数组的迭代使用了一套非常古老的语法, 这让人联想到了C语言而不是一门面向对象的语言. ES5引入了 <code>forEach()</code> 函数以改变这一现状,但是对于每次的迭代依旧需要一次函数调用,这也导致了执行速度的降低. 针对这一点, CoffeeScript 通过一种美妙的语法做了对应的处理:</p>

<p><span class="csscript"></span></p>

<pre><code>for name in ["Roger", "Roderick", "Brian"]
  alert "Release #{name}"
</code></pre>

<p>如果你要得到当前的循环index, 只需要再多传递一个参数:</p>

<p><span class="csscript"></span></p>

<pre><code>for name, i in ["Roger the pickpocket", "Roderick the robber"]
  alert "#{i} - Release #{name}"
</code></pre>

<p>你也可以使用后缀的形式在一行内做循环.</p>

<p><span class="csscript"></span></p>

<pre><code>release prisoner for prisoner in ["Roger", "Roderick", "Brian"]
</code></pre>

<p>如果你熟悉Python的语法, 你可以过滤这些结果:</p>

<p><span class="csscript"></span></p>

<pre><code>prisoners = ["Roger", "Roderick", "Brian"]
release prisoner for prisoner in prisoners when prisoner[0] is "R" 
</code></pre>

<p>你也可以利用自己遍历对象属性的知识来遍历对象, 遍历时要把<code>in</code> 换成<code>of</code>.</p>

<p><span class="csscript"></span></p>

<pre><code>names = sam: seaborn, donna: moss
alert("#{first} #{last}") for first, last of names
</code></pre>

<p>CoffeeScript提供的唯一一个低级别的循环是 <code>while</code> 循环.这和JavaScript中的很相似.不过在CoffeeScript中while多提供了一个返回值, 包含了一个结果的数组.这就类似于<code>Array.prototype.map()</code>函数的功能.</p>

<p><span class="csscript"></span></p>

<pre><code>num = 6
minstrel = while num -= 1
  num + " Brave Sir Robin ran away"
</code></pre>

<h2>数组</h2>

<p>CoffeeScript 在处理数组切割时借鉴了Ruby使用区间的思想. 一个区间的创建需要两个数值, 分别代表区间的初始位置和最终位置, 他们被 <code>..</code> 或是 <code>...</code>所分隔. 如果一个区间没有任何的前缀, CoffeeScript会把它扩充成一个数组.</p>

<p><span class="csscript"></span></p>

<pre><code>range = [1..5]
</code></pre>

<p>然而,如果区间指定后立即被赋予一个变量, CoffeeScript会使用<code>slice()</code> 方法对数组进行转换.</p>

<p><span class="csscript"></span></p>

<pre><code>firstTwo = ["one", "two", "three"][0..1]
</code></pre>

<p>在上面的例子中, 通过区间返回了一个新的数组,它包含了原数组的前两个元素. 你也可以利用这种语法来用另一个数组替换当前数组的一部分.</p>

<p><span class="csscript"></span></p>

<pre><code>numbers = [0..9]
numbers[3..5] = [-3, -4, -5]
</code></pre>

<p>灵活的是,JavaScript允许你使用<code>slice</code>方法来切割字符串, 因此你可以使用字符串的区间来返回一个子字符串.</p>

<p><span class="csscript"></span></p>

<pre><code>my = "my string"[0..2]
</code></pre>

<p>在JavaScript中要检查一个值是否存在于一个数组总是一件麻烦事,我想部分原因是 <code>indexOf()</code> 在全浏览器中的并不是支持的很完美(我想说的是IE).
CoffeeScript通过 <code>in</code> 运算符解决了这一问题.以下是例子.</p>

<p><span class="csscript"></span></p>

<pre><code>words = ["rattled", "roudy", "rebbles", "ranks"]
alert "Stop wagging me" if "ranks" in words 
</code></pre>

<h2>别名 &amp; “存在”操作符</h2>

<p>CoffeeScript 的语法中包含了一些实用的别名,他们节省了你的输入. 其中一个是 <code>@</code>, 他表示的是 <code>this</code>.</p>

<p><span class="csscript"></span></p>

<pre><code>@saviour = true
</code></pre>

<p>另一个是 <code>::</code>, 他是 <code>prototype</code> 的别名</p>

<p><span class="csscript"></span></p>

<pre><code>User::first = -&gt; @records[0]
</code></pre>

<p>在JavaScript通过 <code>if</code> 来检查 <code>null</code> 是很普遍的事情, 但是空字符串和 0 也会被转换成<code>false</code>, 这使得检查往往出现一些疏漏. CoffeeScript 的"存在"操作符 <code>?</code> 只会在一个变量是<code>null</code> 或者是<code>undefined</code> 返回true, 这有点类似于 Ruby的 <code>nil</code>.</p>

<p><span class="csscript"></span></p>

<pre><code>praise if brian?
</code></pre>

<p>你也可以用它来替代 <code>||</code> 操作符:</p>

<p><span class="csscript"></span></p>

<pre><code>velocity = southern ? 40
</code></pre>

<p>如果你是要在获取属性之前做一个 <code>null</code> 的检查. 你可以把"存在"操作符放在属性的访问之前. 这有点类似于Active Support的<a href="http://guides.rubyonrails.org/active_support_core_extensions.html#try"><code>try</code></a> 方法.</p>

<p><span class="csscript"></span></p>

<pre><code>blackKnight.getLegs()?.kick()
</code></pre>

<p>类似的你可以把<code>?</code>放在括号的前面来检查一个属性是否是一个方法并且可被调用.如果这个属性不存在或者并非是一个方法,那么他将不会被执行.
Similarly you can check that a property is actually a function, and callable, by placing the existential operator right before the parens. If the property doesn't exist, or isn't a function, it simply won't get called.</p>

<p><span class="csscript"></span></p>

<pre><code>blackKnight.getLegs().kick?()
</code></pre>

  </div>
</div>
</body>
</html><!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>The Little Book on CoffeeScript - Classes</title>
<link rel="stylesheet" href="site/site.css" type="text/css" charset="utf-8">
<link rel="stylesheet" href="site/highlight.css" type="text/css" charset="utf-8">
<script src="site/jquery.js" type="text/javascript" charset="utf-8"></script>      
<script src="site/highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="site/coffee-script.js" type="text/javascript" charset="utf-8"></script>
<script src="site/preview.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
  hljs.initHighlightingOnLoad();
</script>
</head>
<body>
<div id="container">
  <header>
    <h1><a href="index.html">The Little Book on CoffeeScript</a></h1>
  </header>
  
  <div id="content">
    <div class="back"><a href="index.html">&laquo; 返回章节列表</a></div>


<h1>类</h1>

<p>类在javascritp中发挥的功效很大，就像对付吸血鬼的大蒜头一样，不过话说回来，如果你有这种想法，你很可能不会去看一本coffeescript的书。然而，类在javascript无非只是表现的和它在别的语言里面一样的作用，而coffeescript提供了更好的抽象.</p>

<p>CoffeeScript使用了javascript原生的原形来创建类，并且添加了一些静态属性和保持作用域上的语法糖。而这一切都通过 <code>class</code> 关键字提供给开发者</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
</code></pre>

<p>在上面的例子中, <code>Animal</code> 是类名,我们可以用这个类目来创建变量.CoffeeScript支持构造函数，这意味着你可以通过<code>new</code>操作符来生成实例.</p>

<p><span class="csscript"></span></p>

<pre><code>animal = new Animal
</code></pre>

<p>定义构造函数非常简单，只需定义一个 <code>constructor</code> 函数.这就像我们使用Ruby的 <code>initialize</code> 或者 Python 的 <code>__init__</code>.</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  constructor: (name) -&gt;
    @name = name
</code></pre>

<p>事实上，CoffeeScript提供了一种设定实例属性的缩写方式。只需要在参数前加上<code>@</code>, CoffeeScript会自动的在构造函数中设定实例的属性,事实上，这个缩写方式也适用于普通的类之外的函数。下面的这个例子和我们之前手动设定实例属性的例子是等价的.</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  constructor: (@name) -&gt;
</code></pre>

<p>正如你期望的，任何在初始化过程中传入的参数都会被传入构造函数.</p>

<p><span class="csscript"></span></p>

<pre><code>animal = new Animal("Parrot")
alert "Animal is a #{animal.name}"
</code></pre>

<h2>实例属性</h2>

<p>给一个类添加额外的实例方法非常的简单。它与对一个对象添加属性的语法一样。只是正确的把方法添加在class之中.</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  price: 5

  sell: (customer) -&gt;

animal = new Animal
animal.sell(new Customer)
</code></pre>

<p>作用域的改变在Javascript中非常普遍，在之前的语法章节，我们谈及了CoffeeScript可以通过 <code>=&gt;</code> 锁定 <code>this</code> 的值到一个固定的执行上下文上面。这就确保了不论函数在什么作用域下运行，他总会在他创建时的执行上下文下执行.</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  price: 5

  sell: =&gt;
    alert "Give me #{@price} shillings!"

animal = new Animal
$("#sell").click(animal.sell)
</code></pre>

<p>上面的例子已经说明，this在事件回调中非常有用。通常来说, <code>sell()</code>函数只会在 <code>#sell</code> 的元素的作用域下面执行。不过通过对<code>sell()</code>函数使用<code>=&gt;</code> 符，我们可以保证它的作用域一直不变。并且 <code>this.price</code> 始终等于 <code>5</code>.</p>

<h2>静态属性</h2>

<p>那么如何定义类的方法(静态方法)呢？很简单，在一个类的定义体中，<code>this</code>指向这个类对象.换句话说,你可以直接在<code>this</code>上面设置静态属性(类属性).</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  this.find = (name) -&gt;      

Animal.find("Parrot")
</code></pre>

<p>你可能还记得，CoffeeScript通过<code>@</code>符来引用 <code>this</code>，这样你能更简洁的编写静态方法:</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  @find: (name) -&gt;

Animal.find("Parrot")
</code></pre>

<h2>继承和超类</h2>

<p>如果没有继承的机制,类的存在也就没有真正的意义, CoffeeScript自然也提供了这方面的语法.你可以使用 <code>extends</code>  关键词从一个类继承自另一个类. 在下面的这个例子中, <code>Parrot</code> 类就继承自 <code>Animal</code> 类, 包括了所有的实例方法, 例如 <code>alive()</code> 方法。</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  constructor: (@name) -&gt;

  alive: -&gt;
    false

class Parrot extends Animal
  constructor: -&gt;
    super("Parrot")

  dead: -&gt;
    not @alive()
</code></pre>

<p>从上一个例子中你可以看到，我们还使用了 <code>super()</code> 关键字. 如此做, this就指向了当前类“父类”的原形, 并且使用当前的作用域来执行. 在对应的js中, 就会生成 <code>Parrot.__super__.constructor.call(this, "Parrot");</code> 这样的一段申明. 实际运用中, 这样就好比是在 Ruby 或者 Python中使用 <code>super</code>, 执行被继承的函数.</p>

<p>通常来说当实例被创建的时候CoffeeScript会执行父类的 <code>constructor</code> 构造函数，除非你自己修改了构造函数.</p>

<p>CoffeeScript使用原形继承来继承一个类的所有实例方法.这保证了所有的类都是动态的; 即便是一个子类被创建后，在父类添加了实例方法，继承于它的子类依然能够使用这个方法.</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  constructor: (@name) -&gt;

class Parrot extends Animal

Animal::rip = true

parrot = new Parrot("Macaw")
alert("This parrot is no more") if parrot.rip
</code></pre>

<p>值得指出的是静态的属性都被拷贝到子类中, 而不是像实例属性那样通过原形来继承. 这主要源于Javascript原型架构的原因.</p>

<h2>混合(Mixins)</h2>

<p><a href="http://en.wikipedia.org/wiki/Mixin">混合(Mixins)</a> 并非CoffeeScript原生支持的特性, 但基于他们的好处，你可以自己写一个. 举例来说，混合包含两个函数, <code>extend()</code> 和 <code>include()</code> 分别可以向一个类中添加类属性和实例属性.</p>

<p><span class="csscript"></span></p>

<pre><code>extend = (obj, mixin) -&gt;
  obj[name] = method for name, method of mixin        
  obj

include = (klass, mixin) -&gt;
  extend klass.prototype, mixin

# Usage
include Parrot,
  isDeceased: true

(new Parrot).isDeceased
</code></pre>

<p>当继承的方式并不适用，但又需要在模块之间共享一些常用的逻辑的时候，混合就是很好的方式。混合的优势在于, 相比于继承的来源只有一个父类，你可以对自己的类加入很多的不同的特性或属性。</p>

<h2>扩展类</h2>

<p>混合(Mixin)非常的简洁优雅，但是他们的写法并没有面向对象. 我们就把Mixin整合进CoffeeScript的类之中. 我们先定义一个叫 <code>Module</code> 的类，通过这个类我们可以继承Mixin的特性. <code>Module</code> 拥有两个静态的方法, <code>@extend()</code> 和 <code>@include()</code>, 通过这两个方法，我们可以分别扩展一个类的静态和实例属性.</p>

<p><span class="csscript"></span></p>

<pre><code>moduleKeywords = ['extended', 'included']

class Module
  @extend: (obj) -&gt;
    for key, value of obj when key not in moduleKeywords
      @[key] = value

    obj.extended?.apply(@)
    this

  @include: (obj) -&gt;
    for key, value of obj when key not in moduleKeywords
      # Assign properties to the prototype
      @::[key] = value

    obj.included?.apply(@)
    this
</code></pre>

<p>The little dance around the moduleKeywords variable is to ensure we have callback support when mixins extend a class. 让我们看看 <code>Module</code> 类如何实际的使用:</p>

<p><span class="csscript"></span></p>

<pre><code>classProperties = 
  find: (id) -&gt;
  create: (attrs) -&gt;

instanceProperties =
  save: -&gt; 

class User extends Module
  @extend classProperties
  @include instanceProperties

# Usage:
user = User.find(1)

user = new User
user.save()
</code></pre>

<p>你可以看到, 我们添加了静态方法 <code>find()</code> 和 <code>create()</code> 到 <code>User</code> 这个类, 另外添加了实例方法 <code>save()</code>. 因为我们有模块扩展的回调, 我们可以通过接受静态和动态的属性来简化这一过程:</p>

<p><span class="csscript"></span></p>

<pre><code>ORM = 
  find: (id) -&gt;
  create: (attrs) -&gt;
  extended: -&gt;
    @include
      save: -&gt; 

class User extends Module
  @extend ORM
</code></pre>

<p>非常简单和高效吧！</p>

  </div>
</div>
</body>
</html><!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>The Little Book on CoffeeScript - Idioms</title>
<link rel="stylesheet" href="site/site.css" type="text/css" charset="utf-8">
<link rel="stylesheet" href="site/highlight.css" type="text/css" charset="utf-8">
<script src="site/jquery.js" type="text/javascript" charset="utf-8"></script>      
<script src="site/highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="site/coffee-script.js" type="text/javascript" charset="utf-8"></script>
<script src="site/preview.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
  hljs.initHighlightingOnLoad();
</script>
</head>
<body>
<div id="container">
  <header>
    <h1><a href="index.html">The Little Book on CoffeeScript</a></h1>
  </header>
  
  <div id="content">
    <div class="back"><a href="index.html">&laquo; 返回章节列表</a></div>


<h1>CoffeeScript常用编程模式</h1>

<p>每一种语言都有自己的惯用语法和编程的模式, CoffeeScript也不例外. 这一章就会涉及这些内容, 并且会对比JavaScript和CoffeeScript之间的区别，以便你能对CoffeeScript有更好的理解.</p>

<h2>遍历</h2>

<p>在JavaScript中遍历一个数组的每一项, 我们可以使用新增加的 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/foreach"><code>forEach()</code></a> 函数, 或者是用一个 C 风格的 <code>for</code> 循环. 如果你计划使用一些最新的JavaScript特性，我建议你在页面中引入 <a href="https://github.com/kriskowal/es5-shim">shim</a> 来支持旧的浏览器.</p>

<pre><code>for (var i=0; i &lt; array.length; i++)
  myFunction(array[i]);

array.forEach(function(item, i){
  myFunction(item)
});
</code></pre>

<p>尽管 <code>forEach()</code> 在语法上面更加的简介和可读, 但是它也受限于它的通过回调来执行的缺陷, 相比 <code>for</code> 循环就要慢许多. 让我们来看看在CoffeeScript里面是怎么样的.</p>

<p><span class="csscript"></span></p>

<pre><code>myFunction(item) for item in array
</code></pre>

<p>这样的语法更加可读，并且更加简洁， 我想你也会这么认为，并且所有的这一切都是在后台被编译为 <code>for</code> 循环. 换句话说 CoffeeScript 的语法提供了 <code>forEach()</code> 般的表现力, 并且解决了速度和低浏览器模拟的问题.</p>

<h2>图</h2>

<p>和 <code>forEach()</code> 类似, ES5 同样提供了一个原生的<a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/map"><code>map()</code></a>函数来代替 <code>for</code> 循环 . 不幸的是它的情况和 <code>forEach()</code> 类似, 因为调用方式的问题，它的速度也打了折扣.</p>

<pre><code>var result = []
for (var i=0; i &lt; array.length; i++)
  result.push(array[i].name)

var result = array.map(function(item, i){
  return item.name;
});
</code></pre>

<p>As we covered in the syntax chapter, CoffeeScript's comprehensions can be used to get the same behavior as <code>map()</code>. Notice we're surrounding the comprehension with parens, which is <strong>absolutely critical</strong> in ensuring the comprehension returns what you'd expect, the mapped array.</p>

<p>我们之前的语法部分介绍了, CoffeeScript的语句同样可以构造出类似 <code>map()</code> 的行为. 要注意的是我们在语句外面包了一层括号, 这非常<strong>关键</strong>,它确保语句返回的是我们想要的键值化数组.</p>

<p><span class="csscript"></span></p>

<pre><code>result = (item.name for item in array)
</code></pre>

<h2>筛选</h2>

<p>ES5 有一个功能函数 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/filter"><code>filter()</code></a> 用来筛选数组:</p>

<pre><code>var result = []
for (var i=0; i &lt; array.length; i++)
  if (array[i].name == "test")
    result.push(array[i])

result = array.filter(function(item, i){
  return item.name == "test"
});
</code></pre>

<p>CoffeeScript的基础语法则提供了 <code>when</code> 通过比较来进行数组条目的筛选. 这同样会生成一个 <code>for</code> 循环. 整个执行的过程会在一个匿名函数中进行，以避免作用域泄漏以及变量冲突.</p>

<p><span class="csscript"></span></p>

<pre><code>result = (item for item in array when item.name is "test")
</code></pre>

<p>别忘了加上括号, 否则 <code>result</code> 的值会是最后一个被筛选出来的条目.
CoffeeScript的语法非常的灵活, 下面的这个例子很好的展示了CoffeeScript强大的筛选功能.
<span class="csscript"></span></p>

<pre><code>passed = []
failed = []
(if score &gt; 60 then passed else failed).push score for score in [49, 58, 76, 82, 88, 90]

# Or
passed = (score for score in scores when score &gt; 60)
</code></pre>

<p>如果这样理解过于麻烦, 你可以把他们分成多行.</p>

<p><span class="csscript"></span></p>

<pre><code>passed = []
failed = []
for score in [49, 58, 76, 82, 88, 90]
  (if score &gt; 60 then passed else failed).push score
</code></pre>

<h2>包含</h2>

<p>我们常常会使用<code>indexOf()</code>方法来判断一个值是不是属于一个数组, 但由于IE还没有支持, 我们还是需要做一些兼容性的处理.</p>

<pre><code>var included = (array.indexOf("test") != -1)
</code></pre>

<p>许多Python开发者可能已经发现, 在CoffeeScript中使用了 <code>in</code> 来完美替代这个处理过程.</p>

<p><span class="csscript"></span></p>

<pre><code>included = "test" in array
</code></pre>

<p>在实际实现中, CoffeeScript使用了 <code>Array.prototype.indexOf()</code> 来检测一个值是否存在于一个数组中, 如果不支持这个, 就做降级处理.不幸的是, 这样做意味着<code>in</code>的语法不能对字符串无效.所以对于字串我们还得用回<code>indexOf()</code>, 并同时判断结果是否为-1:</p>

<p><span class="csscript"></span></p>

<pre><code>included = "a long test string".indexOf("test") isnt -1
</code></pre>

<p>或者我们改进一下, 使用位运算符这样就避免了和 <code>-1</code> 做对比.</p>

<p><span class="csscript"></span></p>

<pre><code>string   = "a long test string"
included = !!~ string.indexOf "test"
</code></pre>

<h2>属性遍历</h2>

<p>要在JavaScript中遍历一堆属性的话, 你需要使用<code>in</code>操作符, 举个例子:</p>

<pre><code>var object = {one: 1, two: 2}
for(var key in object) alert(key + " = " + object[key])
</code></pre>

<p>然而,正如你之前看到的,CoffeeScript已经把 <code>in</code> 关键字运用在了数组中. 这样一来,我们在CoffeeScript中使用 <code>of</code> 这个关键字来代替</p>

<p><span class="csscript"></span></p>

<pre><code>object = {one: 1, two: 2}
alert("#{key} = #{value}") for key, value of object
</code></pre>

<p>As you can see, you can specify variables for both the property name, and its value; rather convenient.
你可以看到,你可以同时获取属性名和属性值,相当的方便.</p>

<h2>最大值/最小值</h2>

<p>这个技术或许在CoffeeScript中并不算特别, 但是我想说说它的特别之处. <code>Math.max</code> 和 <code>Math.min</code> 可以接受多个参数,你可以使用 <code>...</code> 来传递一个数组给它们, 从而得到这个数组中的最大值和最小值.</p>

<p><span class="csscript"></span></p>

<pre><code>Math.max [14, 35, -7, 46, 98]... # 98
Math.min [14, 35, -7, 46, 98]... # -7
</code></pre>

<p>由于浏览器对函数参数的数量的限制问题,这个技巧在传递一个很大的数组的时候是没有什么意义的.</p>

<h2>多个参数</h2>

<p>在<code>Math.max</code>的例子中, 我们使用了 <code>...</code> 来构建一个数组并把它作为多个参数传递给 <code>max</code>.
实际实现中, CoffeeScript通过<code>apply()</code>调用的方式来进行函数的调用, 以保证数组作为一个参数传递给<code>max</code>, 我们可以换种方式来运用这一特性, 譬如说,proxying function calls:</p>

<p><span class="csscript"></span></p>

<pre><code>Log =
  log: -&gt;
    console?.log(arguments...)
</code></pre>

<p>或者你可一在参数被传入之前做一下修改.</p>

<p><span class="csscript"></span></p>

<pre><code>Log =
  logPrefix: "(App)"

  log: (args...) -&gt;
    args.unshift(@logPrefix) if @logPrefix
    console?.log(args...)
</code></pre>

<p>虽然你会感觉有些担心，但是CoffeeScript是会自动设置函数的执行上下文为函数触发时所属的对象.上面的例子中,上下文应该是 <code>console</code>. 如果你要设定特定的上下文,那么你就要手动的使用<code>apply()</code>的调用方式.</p>

<h2>与/非</h2>

<p>CoffeeScript 风格指南推荐用 <code>or</code> 代替 <code>||</code>, 用 <code>and</code> 代替 <code>&amp;&amp;</code>. 我说说为什么, 因为前者可读性更佳. 除此之外, 这两种方式的结果是一致的.</p>

<p>这种更接近英语的风格还有,如使用<code>is</code> 优于 <code>==</code> , <code>isnt</code> 优于 <code>!=</code>.</p>

<p><span class="csscript"></span></p>

<pre><code>string = "migrating coconuts"
string == string # true
string is string # true
</code></pre>

<p>CoffeeScript还添加了一个很棒的'或等于'的判断符,Ruby的程序员可能能很快认出来这和<code>||=</code>很相近.</p>

<p><span class="csscript"></span></p>

<pre><code>hash or= {}
</code></pre>

<p>如果hash等于<code>false</code>, 那么它就会被赋一个空对象的值. 需要注意的是, 这个表达式也会把<code>0</code>,<code>""</code>,<code>null</code>认成非值.如果你并不想这样,那就使用CoffeeScript的“存在”操作符, 它可以保证只在hash为<code>undefined</code>或是<code>null</code>的时候才被赋值:</p>

<p><span class="csscript"></span></p>

<pre><code>hash ?= {}
</code></pre>

<h2>析构赋值</h2>

<p>析构赋值可以被用来获取数组或者对象的深度属性.</p>

<p><span class="csscript"></span></p>

<pre><code>someObject = { a: 'value for a', b: 'value for b' }
{ a, b } = someObject
console.log "a is '#{a}', b is '#{b}'"
</code></pre>

<p>这在Node应用中引用模块的时候非常的有用:</p>

<p><span class="csscript"></span></p>

<pre><code>{join, resolve} = require('path')

join('/Users', 'Alex')
</code></pre>

<h2>外部库</h2>

<p>使用外部库和调用CoffeeScript的库的函数的方式基本一样, 因为最终所有的东西都会编译为JavaScript. 由于Jquery本身API设计包含了很多的回调, 在CoffeeScript中使用<a href="http://jquery.com">jQuery</a>会显得很顺其自然。</p>

<p><span class="csscript"></span></p>

<pre><code># Use local alias
$ = jQuery

$ -&gt;
  # DOMContentLoaded
  $(".el").click -&gt;
    alert("Clicked!")
</code></pre>

<p>由于所有的CoffeeScript产物都会被一个匿名函数所包裹, 我们可以设定一个本地变量 <code>$</code> 指向 <code>jQuery</code>.这可以保证即便jQuery冲突模式没有被开启,并且<code>$</code>被别的框架重写,我们的脚本依旧能工作正常.</p>

<h2>私有变量</h2>

<p><code>do</code> 关键字可以让我们在CoffeeScript中立即执行函数, 这是一种很好的封装作用域保护变量的方式.下面的例子中, 我们在一个使用<code>do</code>立即执行的匿名函数中定义了一个<code>classToType</code>变量.这个匿名函数返回了另一个匿名函数, 它会返回<code>type</code>的最终值.由于<code>classToType</code>被定义的上下文没有任何引用,外部作用域就无法访问它.</p>

<p><span class="csscript"></span></p>

<pre><code># Execute function immediately
type = do -&gt;
  classToType = {}
  for name in "Boolean Number String Function Array Date RegExp Undefined Null".split(" ")
    classToType["[object " + name + "]"] = name.toLowerCase()

  # Return a function
  (obj) -&gt;
    strType = Object::toString.call(obj)
    classToType[strType] or "object"
</code></pre>

<p>换句话说, <code>classToType</code> 的作用域是完全私有的, 并且不再会被匿名函数外部所引用.这种方式可以很好的封装作用域和隐藏变量.</p>

  </div>
</div>
</body>
</html><!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>The Little Book on CoffeeScript - Compiling</title>
<link rel="stylesheet" href="site/site.css" type="text/css" charset="utf-8">
<link rel="stylesheet" href="site/highlight.css" type="text/css" charset="utf-8">
<script src="site/jquery.js" type="text/javascript" charset="utf-8"></script>      
<script src="site/highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="site/coffee-script.js" type="text/javascript" charset="utf-8"></script>
<script src="site/preview.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
  hljs.initHighlightingOnLoad();
</script>
</head>
<body>
<div id="container">
  <header>
    <h1><a href="index.html">The Little Book on CoffeeScript</a></h1>
  </header>
  
  <div id="content">
    <h1>Automating CoffeeScript compilation</h1>

<p>An issue with CoffeeScript is that it puts another layer between you and JavaScript, and having to manually compile CoffeeScript files whenever they change quickly gets old. Fortunately CoffeeScript has some alternative forms of compilation which can make the development cycle somewhat smoother.</p>

<p>As we covered in the first chapter, we can compile CoffeeScript files using the <code>coffee</code> executable:</p>

<pre><code>coffee --compile --output lib src
</code></pre>

<p>In fact in the example above, all the <code>.coffee</code> files in <code>src</code> will be compiled &amp; their JavaScript outputted to the <code>lib</code> directory. Even calling that is a bit of a bore, so let's look into automating it.</p>

<h2>Cake</h2>

<p><a href="http://jashkenas.github.com/coffee-script/#cake">Cake</a> is a super simple build system along the lines of <a href="http://www.gnu.org/software/make/">Make</a> and <a href="http://rake.rubyforge.org/">Rake</a>. The library is bundled with the <code>coffee-script</code> npm package, and available via an executable called <code>cake</code>.</p>

<p>You can define tasks using CoffeeScript in a file called <code>Cakefile</code>. Cake will pick these up, and can be invoked by running <code>cake [task] [options]</code> from within the directory. To print a list of all the tasks and options, just type <code>cake</code>.</p>

<p>Tasks are defined using the <code>task()</code> function, passing a name, optional description and callback function. For example, create a file called <code>Cakefile</code>, and two directories, <code>lib</code> and <code>src</code>. Add the following to the <code>Cakefile</code>:</p>

<p><span class="csscript"></span></p>

<pre><code>fs = require 'fs'

{print} = require 'sys'
{spawn} = require 'child_process'

build = (callback) -&gt;
  coffee = spawn 'coffee', ['-c', '-o', 'lib', 'src']
  coffee.stderr.on 'data', (data) -&gt;
    process.stderr.write data.toString()
  coffee.stdout.on 'data', (data) -&gt;
    print data.toString()
  coffee.on 'exit', (code) -&gt;
    callback?() if code is 0

task 'build', 'Build lib/ from src/', -&gt;
  build()
</code></pre>

<p>In the example above, we're defining a task called <code>build</code> that can be invoked by running: <code>cake build</code>. This runs the same command as the previous example, compiling all the CoffeeScript files in <code>src</code> to JavaScript in <code>lib</code>. You can now reference JavaScript files in the <code>lib</code> directory as per usual from your HTML:</p>

<p><span class="csscript"></span></p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=utf-8&gt;
&lt;script src="lib/app.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;      
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>We're still having to manually run <code>cake build</code> whenever our CoffeeScript code changes, which is far from ideal. Luckily, the <code>coffee</code> command takes another option, <code>--watch</code>, which instructs it to watch a directory for changes and re-compiling as necessary. Let's define another task using that:</p>

<p><span class="csscript"></span></p>

<pre><code> task 'watch', 'Watch src/ for changes', -&gt;
    coffee = spawn 'coffee', ['-w', '-c', '-o', 'lib', 'src']
    coffee.stderr.on 'data', (data) -&gt;
      process.stderr.write data.toString()
    coffee.stdout.on 'data', (data) -&gt;
      print data.toString()
</code></pre>

<p>If one task relies on another, you can run other tasks using <code>invoke(name)</code>. Let's add a utility task to our <code>Cakefile</code> which is going to both open  <code>index.html</code> and start watching the source for changes.</p>

<p><span class="csscript"></span></p>

<pre><code>task 'open', 'Open index.html', -&gt;
  # First open, then watch
  spawn 'open', 'index.html'
  invoke 'watch'
</code></pre>

<p>You can also define options for your task using the <code>option()</code> function, which takes a short name, long name and description.</p>

<p><span class="csscript"></span></p>

<pre><code>option '-o', '--output [DIR]', 'output dir'

task 'build', 'Build lib/ from src/', -&gt;
  # Now we have access to a `options` object
  coffee = spawn 'coffee', ['-c', '-o', options.output or 'lib', 'src']
  coffee.stderr.on 'data', (data) -&gt;
    process.stderr.write data.toString()
  coffee.stdout.on 'data', (data) -&gt;
    print data.toString()
</code></pre>

<p>As you can see, the task context now has access to an <code>options</code> object containing any data specified by the user. If we run <code>cake</code> without any other arguments, all the tasks and options will be listed.</p>

<p>Cake's a great way of automating common tasks such as compiling CoffeeScript without going to the hassle of using bash or Makefiles. It's also worth taking a look at <a href="http://jashkenas.github.com/coffee-script/documentation/docs/cake.html">Cake's source</a>, a great example of CoffeeScript's expressiveness and beautifully documented alongside the code comments.</p>

<h2>Server side support</h2>

<p>Using Cake for CoffeeScript compilation is fine for static sites, but for dynamic sites we might as well integrate CoffeeScript compilation into the request/response cycle. Various integration solutions already exist for the popular backend languages and frameworks, such as <a href="http://rubyonrails.org/">Rails</a> and <a href="https://www.djangoproject.com/">Django</a>.</p>

<p>When it comes to Rails 3.1, CoffeeScript support comes via <a href="https://github.com/sstephenson/sprockets">Sprockets &amp; the asset pipeline</a>. Add your CoffeeScript files under <code>app/assets/javascripts</code>, and Rails is smart enough to pre-compile them when they're requested. JavaScript &amp; CoffeeScript files are concatenated and bundled using special comment directives, meaning you can fetch all of your application's JavaScript with one request. When it comes to production, Rails will write the compiled output to disk, ensuring it's cached and fast to serve.</p>

<p>Other Ruby options include Rack servers such as 37signal's <a href="http://pow.cx/">Pow</a> and Joshua Peek's <a href="http://josh.github.com/nack/">Nack</a>, both highly recommended if your application doesn't need Rail's other features and associated overhead.</p>

<p>Django also has <a href="http://pypi.python.org/pypi/django-coffeescript/">support for CoffeeScript</a> through special template tags. It works with both inline code and external files.</p>

<p>Both Ruby and Python pipe out to Node and the CoffeeScript lib behind the scenes when compiling CoffeeScript, so you'll need to have those installed during development. If you're using Node directly as a backend for your site, CoffeeScript integration is even simpler and you can use it for both the backend and frontend code. We're going to talk more about this in the next chapter, using <a href="https://github.com/sstephenson/stitch">Stitch</a> to serve all our client-side CoffeeScript.</p>

  </div>
</div>
</body>
</html><!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>The Little Book on CoffeeScript - Applications</title>
<link rel="stylesheet" href="site/site.css" type="text/css" charset="utf-8">
<link rel="stylesheet" href="site/highlight.css" type="text/css" charset="utf-8">
<script src="site/jquery.js" type="text/javascript" charset="utf-8"></script>      
<script src="site/highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="site/coffee-script.js" type="text/javascript" charset="utf-8"></script>
<script src="site/preview.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
  hljs.initHighlightingOnLoad();
</script>
</head>
<body>
<div id="container">
  <header>
    <h1><a href="index.html">The Little Book on CoffeeScript</a></h1>
  </header>
  
  <div id="content">
    <div class="back"><a href="index.html">&laquo; Back to all chapters</a></div>


<h1>Creating Applications</h1>

<p>Now you've been given an overview of the syntax, lets explore actually structuring and creating CoffeeScript applications. This section aims to be useful to all CoffeeScript developers, novice or advanced. Indeed, it should be relevant to pure JavaScript developers too.</p>

<p>For some reason, when developers are building client side JavaScript applications, tried and tested patterns and conventions often fly out the window, and the end result is a spaghetti mess of un-maintainable coupled JavaScript. I can't stress enough how important application architecture is; if you're writing any JavaScript/CoffeeScript beyond simple form validation you should implement a form of application structure, such as <a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a>.</p>

<p>The secret to building maintainable large applications is not to build large applications. In other words, build a series of modular de-coupled components. Keep application logic as generic as possible, abstracting it out as appropriate. Lastly separate out your logic into views, models and controllers (MVC). Implementing MVC is beyond the scope of this chapter, for that I recommend you check out my book on <a href="http://oreilly.com/catalog/9781449307530/">JavaScript Web Applications</a> and use a framework like <a href="http://documentcloud.github.com/backbone/">Backbone</a> or <a href="https://github.com/maccman/spine">Spine</a>. Rather than that, here we're going to cover structuring applications using CommonJS modules.</p>

<h2>Structure &amp; CommonJS</h2>

<p>So what exactly are CommonJS modules? Well, If you've used <a href="http://nodejs.org/">NodeJS</a> before you've used CommonJS modules, probably without realizing it. CommonJS modules were initially developed for writing server side JavaScript libraries, in an attempt to deal with loading, namespacing and scoping issues. They were a common format that would be compatible across all JavaScript implementations. The aim was that a library written for <a href="http://www.mozilla.org/rhino/">Rhino</a> would work for Node. Eventually these ideas transitioned back to browsers, and now we have great libraries like <a href="http://requirejs.org">RequireJS</a> and <a href="https://github.com/jbrantly/yabble">Yabble</a> to use modules client-side.</p>

<p>Practically speaking, modules ensure that your code is run in a local namespace (code encapsulation), that you can load other modules with the <code>require()</code> function, and expose module properties via <code>module.exports</code>. Let's dive into that in a bit more depth now.</p>

<h3>Requiring files</h3>

<p>You can load in other modules and libraries using <code>require()</code>. Simply pass a module name and, if it's in the load path, it'll return an object representing that module. For example:</p>

<pre><code>User = require("models/user")
</code></pre>

<p>Synchronous require support is a contentious issue, but has mostly been resolved with the mainstream loader libraries and latest CommonJS <a href="http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition">proposals</a>. It may be something you'll have to look into if you decided to take a separate route than the one I'm advocating with Stitch below.</p>

<h3>Exporting properties</h3>

<p>By default, modules don't expose any properties so their contents are completely invisible to <code>require()</code> calls. If you want a particular property to be accessible from your module, you'll need to set it on <code>module.exports</code>:</p>

<pre><code># random_module.js
module.exports.myFineProperty = -&gt;
  # Some shizzle
</code></pre>

<p>Now, whenever this module is required then <code>myFineProperty</code> will be exposed:</p>

<pre><code>myFineProperty = require("random_module").myFineProperty
</code></pre>

<h2>Stitch it up</h2>

<p>Formatting your code as CommonJS modules is all fine and dandy, but how do you actually get this working on the client in practice? Well, my method of choice is the rather unheard of <a href="https://github.com/sstephenson/stitch">Stitch</a> library. Stitch is by Sam Stephenson, the mind behind <a href="http://www.prototypejs.org">Prototype.js</a> amongst other things, and solves the module problem so elegantly it makes me want to dance for joy! Rather than try and dynamically resolve dependencies, Stitch simply bundles up all your JavaScript files into one, wrapping them in some CommonJS magic. Oh, and did I mention it'll compile your CoffeeScript, JS templates, <a href="http://lesscss.org">LESS CSS</a> and <a href="http://sass-lang.com">Sass</a> files too!</p>

<p>First things first, you'll need to install <a href="http://nodejs.org/">Node.js</a> and <a href="http://npmjs.org/">npm</a> if you haven't already, we'll be using those throughout this chapter.</p>

<p>Now let's create our application structure. If you're using <a href="https://github.com/maccman/spine">Spine</a>, you can automate this with <a href="http://github.com/maccman/spine.app">Spine.App</a>, otherwise it's something you'll need to do manually. I usually have an <code>app</code> folder for all the application specific code, and a <code>lib</code> folder for general libraries. Then anything else, including static assets, goes in the <code>public</code> directory.</p>

<pre><code>app
app/controllers
app/views
app/models
app/lib
lib
public
public/index.html
</code></pre>

<p>Now to actually boot up the Stitch server. Let's create a file called <code>index.coffee</code> and fill it with the following script:</p>

<p><span class="csscript"></span></p>

<pre><code>require("coffee-script")
stitch  = require("stitch")
express = require("express")
argv    = process.argv.slice(2)

package = stitch.createPackage(
  # Specify the paths you want Stitch to automatically bundle up
  paths: [ __dirname + "/app" ]

  # Specify your base libraries
  dependencies: [
    # __dirname + '/lib/jquery.js'
  ]
)
app = express.createServer()

app.configure -&gt;
  app.set "views", __dirname + "/views"
  app.use app.router
  app.use express.static(__dirname + "/public")
  app.get "/application.js", package.createServer()

port = argv[0] or process.env.PORT or 9294
console.log "Starting server on port: #{port}"
app.listen port
</code></pre>

<p>You can see some dependencies listed: <code>coffee-script</code>, <code>stitch</code> and <code>express</code>. We need to create a <code>package.json</code> file, listing these dependencies so npm can pick them up. Our <code>./package.json</code> file will look like this:</p>

<pre><code>{
  "name": "app",
  "version": "0.0.1",
  "dependencies": { 
    "coffee-script": "~1.1.2",
    "stitch": "~0.3.2",
    "express": "~2.5.0",
    "eco": "1.1.0-rc-1"
  }
}
</code></pre>

<p>And let's install those dependencies with npm:</p>

<pre><code>npm install .
npm install -g coffee-script
</code></pre>

<p>Rightio, we're almost there. Now run:</p>

<pre><code>coffee index.coffee
</code></pre>

<p>You'll hopefully have a Stitch server up and running. Let's go ahead and test it out by putting an <code>app.coffee</code> script in the <code>app</code> folder. This will be the file that'll bootstrap our application.</p>

<p><span class="csscript"></span></p>

<pre><code>module.exports = App =
  init: -&gt;
    # Bootstrap the app
</code></pre>

<p>Now let's create our main page <code>index.html</code> which, if we're building a single page app, will be the only page the user actually navigates to. This is a static asset, so it's located under the <code>public</code> directory.</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=utf-8&gt;
  &lt;title&gt;Application&lt;/title&gt;
  &lt;!-- Require the main Stitch file --&gt;
  &lt;script src="/application.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;
  &lt;script type="text/javascript" charset="utf-8"&gt;
    document.addEventListener("DOMContentLoaded", function(){
      var App = require("app");
      App.init();
    }, false);
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>When the page loads, our <em>DOMContentLoaded</em> event callback is requiring the <code>app.coffee</code> script (which is automatically compiled), and invoking our <code>init()</code> function. That's all there is to it, we've got CommonJS modules up and running, as well as a HTTP server and CoffeeScript compiler. If, say, we wanted to include a module, it's just a case of calling <code>require()</code>. Let's create a new class, <code>User</code>, and reference it from <code>app.coffee</code>:</p>

<p><span class="csscript"></span></p>

<pre><code># app/models/user.coffee
module.exports = class User
  constructor: (@name) -&gt;

# app/app.coffee
User = require("models/user")
</code></pre>

<h2>JavaScript templates</h2>

<p>If you're moving logic to the client side, then you'll definitely need some sort of templating library. JavaScript templating is very similar to templates on the server, such as Ruby's ERB or Python's text interpolation, expect of course it runs client side. There are a whole host of templating libraries out there, so I encourage you to do some research and check them out. By default, Stitch comes with support for <a href="https://github.com/sstephenson/eco">Eco</a> templates baked right in.</p>

<p>JavaScript templates are very similar to server side ones. You have template tags interoperated with HTML, and during rendering those tags get evaluated and replaced. The great thing about <a href="https://github.com/sstephenson/eco">Eco</a> templates, is they're actually written in CoffeeScript.</p>

<p>Here's an example:</p>

<pre><code>&lt;% if @projects.length: %&gt;
  &lt;% for project in @projects: %&gt;
    &lt;a href="&lt;%= project.url %&gt;"&gt;&lt;%= project.name %&gt;&lt;/a&gt;
    &lt;p&gt;&lt;%= project.description %&gt;&lt;/p&gt;
  &lt;% end %&gt;
&lt;% else: %&gt;
  No projects
&lt;% end %&gt;
</code></pre>

<p>As you can see, the syntax is remarkably straightforward. Just use <code>&lt;%</code> tags for evaluating expressions, and <code>&lt;%=</code> tags for printing them. A partial list of template tags is as follows:</p>

<ul>
<li><p><code>&lt;% expression %&gt;</code><br/>
Evaluate a CoffeeScript expression without printing its return value.</p></li>
<li><p><code>&lt;%= expression %&gt;</code><br/>
Evaluate a CoffeeScript expression, escape its return value, and print it.</p></li>
<li><p><code>&lt;%- expression %&gt;</code><br/>
Evaluate a CoffeeScript expression and print its return value without escaping it.</p></li>
</ul>


<p>You can use any CoffeeScript expression inside the templating tags, but there's one thing to look out for. CoffeeScript is whitespace-sensitive, but your Eco templates aren't. Therefore, Eco template tags that begin an indented CoffeeScript block must be suffixed with a colon. To indicate the end of an indented block, use the special tag <code>&lt;% end %&gt;</code>. For example:</p>

<pre><code>&lt;% if @project.isOnHold(): %&gt;
  On Hold
&lt;% end %&gt;
</code></pre>

<p>You don't need to write the <code>if</code> and <code>end</code> tags on separate lines:</p>

<pre><code>&lt;% if @project.isOnHold(): %&gt; On Hold &lt;% end %&gt;
</code></pre>

<p>And you can use the single-line postfix form of <code>if</code> as you'd expect:</p>

<pre><code>&lt;%= "On Hold" if @project.isOnHold() %&gt;
</code></pre>

<p>Now we've got a handle on the syntax, let's define an Eco template in <code>views/users/show.eco</code>:</p>

<pre><code>&lt;label&gt;Name: &lt;%= @name %&gt;&lt;/label&gt;
</code></pre>

<p>Stitch will automatically compile our template and include it in <code>application.js</code>. Then, in our application's controllers we can require the template, like it was a module, and execute it passing any data required.</p>

<p><span class="csscript"></span></p>

<pre><code>require("views/users/show")(new User("Brian"))
</code></pre>

<p>Our <code>app.coffee</code> file should now look like this, rendering the template and appending it to the page when the document loads:</p>

<p><span class="csscript"></span></p>

<pre><code>User = require("models/user")

App =
  init: -&gt;
    template = require("views/users/show")
    view     = template(new User("Brian"))

    # Obviously this could be spruced up by jQuery
    element = document.createElement("div")
    element.innerHTML = view
    document.body.appendChild(element)

module.exports = App
</code></pre>

<p>Open up <a href="http://localhost:9294/">the application</a> and give it a whirl! Hopefully this tutorial has given you a good idea of how to structure client-side CoffeeScript applications. For your next steps, I recommend checking out a client-side framework like <a href="http://documentcloud.github.com/backbone/">Backbone</a> or <a href="http://spinejs.com">Spine</a>, They'll provide a basic MVC structure for you, freeing you up for the interesting stuff.</p>

<h2>Bonus - 30 second deployment with Heroku</h2>

<p><a href="http://heroku.com/">Heroku</a> is an incredibly awesome web host that manages all the servers and scaling for you, letting you get on with the exciting stuff (building awesome JavaScript applications). You'll need an account with Heroku for this tutorial to work, but the great news is that their basic plan is completely free. While traditionally a Ruby host, Heroku have recently released their Cedar stack, which includes Node support.</p>

<p>Firstly we need to make a <code>Procfile</code>, which will inform Heroku about our application.</p>

<pre><code>echo "web: coffee index.coffee" &gt; Procfile
</code></pre>

<p>Now, if you haven't already, you'll need to create a local git repository for your application.</p>

<pre><code>git init
git add .
git commit -m "First commit"    
</code></pre>

<p>And now to deploy the application, we'll use the <code>heroku</code> gem (which you'll need to install if you haven't already).</p>

<pre><code>heroku create myAppName --stack cedar
git push heroku master
heroku open
</code></pre>

<p>That's it! Seriously, that's all there is to it. Hosting Node applications has never been easier.</p>

<h2>Additional libraries</h2>

<p><a href="https://github.com/sstephenson/stitch">Stitch</a> and <a href="https://github.com/sstephenson/eco">Eco</a> aren't the only libraries you can use for creating CoffeeScript &amp; Node applications, there are a variety of alternatives.</p>

<p>For example, when it comes to templating, you can use <a href="http://mustache.github.com">Mustache</a>, <a href="http://jade-lang.com">Jade</a> or write your HTML in pure CoffeeScript using <a href="http://coffeekup.org">CoffeeKup</a>.</p>

<p>As for serving up application, <a href="http://github.com/maccman/hem">Hem</a> is a great choice, supporting both CommonJS and NPM modules and integrating seamlessly with the CoffeeScript MVC framework <a href="http://spinejs.com">Spine</a>. <a href="https://github.com/substack/node-browserify">node-browsify</a> is another similar project. Or if you want to go lower level with <a href="http://expressjs.com/">express</a> integration, there's Trevor Burnham's <a href="https://github.com/TrevorBurnham/connect-assets">connect-assets</a></p>

<p>You can find a full list of CoffeeScript web framework plugins, on the <a href="https://github.com/jashkenas/coffee-script/wiki/Web-framework-plugins">project's wiki</a>.</p>

  </div>
</div>
</body>
</html><!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>The Little Book on CoffeeScript - The Bad Parts</title>
<link rel="stylesheet" href="site/site.css" type="text/css" charset="utf-8">
<link rel="stylesheet" href="site/highlight.css" type="text/css" charset="utf-8">
<script src="site/jquery.js" type="text/javascript" charset="utf-8"></script>      
<script src="site/highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="site/coffee-script.js" type="text/javascript" charset="utf-8"></script>
<script src="site/preview.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
  hljs.initHighlightingOnLoad();
</script>
</head>
<body>
<div id="container">
  <header>
    <h1><a href="index.html">The Little Book on CoffeeScript</a></h1>
  </header>
  
  <div id="content">
    <div class="back"><a href="index.html">&laquo; Back to all chapters</a></div>


<h1>The Bad Parts</h1>

<p>JavaScript is a tricky beast, and knowing the parts that you should avoid is just as important as knowing about the parts you should use. As Sun Tzu says, "know your enemy", and that's exactly what we're going to do in the chapter, exploring the dark side of JavaScript and revealing all the lurking monsters ready to pounce on the unsuspecting developer.</p>

<p>As I mentioned in the introduction, CoffeeScript's awesomeness lies not only in it's syntax, but in it's ability to fix some of JavaScript's warts. However, due to the fact that CoffeeScript statements have a direct translation into JavaScript, and don't run in a virtual machine or interpreter, the language is not a silver bullet to all of JavaScript's bugbears and there's still some issues you need to be aware about.</p>

<p>First, let's talk about what things the language does solve.</p>

<h2>A JavaScript Subset</h2>

<p>CoffeeScript's syntax only covers a subset of JavaScript's, the famous <em>Good Parts</em>, so already there's less to fix. Let's take the <code>with</code> statement for example. This statement has for a long time been "considered harmful", and should be avoided. <code>with</code> was intended to provide a shorthand for writing recurring property lookups on objects. For example, instead of writing:</p>

<pre><code>dataObj.users.alex.email = "info@eribium.org";
</code></pre>

<p>You could write:</p>

<pre><code>with(dataObj.users.alex) {
  email = "info@eribium.org";
}
</code></pre>

<p>Setting aside the fact that we shouldn't have such a deep object in the first place, the syntax is quite clean. Except for one thing. It's damn confusing to the JavaScript interpreter - it doesn't know exactly what you're going to do in the <code>with</code> context, and forces the specified object to be searched first for all name lookups.</p>

<p>This really hurts performance and means the interpreter has to turn off all sorts of JIT optimizations. Additionally <code>with</code> statements can't be minified using tools like <a href="https://github.com/mishoo/UglifyJS">uglify-js</a>. They're also deprecated and removed from future JavaScript versions. All things considered, it's much better just to avoid using them, and CoffeeScript takes this a step further by eliminating them from it's syntax. In other words, using <code>with</code> in CoffeeScript will throw a syntax error.</p>

<h2>Global variables</h2>

<p>By default, your JavaScript programs run in a global scope, and by default any variables created are in that global scope. If you want to create a variable in the local scope, JavaScript requires explicitly indicating that fact using the <code>var</code> keyword.</p>

<pre><code>usersCount = 1;        // Global
var groupsCount = 2;   // Global

(function(){              
  pagesCount = 3;      // Global
  var postsCount = 4;  // Local
})()
</code></pre>

<p>This is a bit of an odd decision since the vast majority of the time you'll be creating local variables not global, so why not make that the default? As it stands, developers have to remember to put <code>var</code> statements before any variables they're initializing, or face weird bugs when variables accidentally conflict and overwrite each other.</p>

<p>Luckily CoffeeScript comes to your rescue here by eliminating implicit global variable assignment entirely. In other words, the <code>var</code> keyword is reserved in CoffeeScript, and will trigger a syntax error if used. Local variables are created implicitly by default, and it's very difficult to create global variables without explicitly assigning them as properties on <code>window</code>.</p>

<p>Let's have a look at an example of CoffeeScript's variable assignment:</p>

<p><span class="csscript"></span></p>

<pre><code>outerScope = true
do -&gt;
  innerScope = true
</code></pre>

<p>Compiles down to:</p>

<pre><code>var outerScope;
outerScope = true;
(function() {
  var innerScope;
  return innerScope = true;
})();
</code></pre>

<p>Notice how CoffeeScript initializes variables (using <code>var</code>) automatically in the context their first used. Whilst it's impossible to shadow outer variables, you can still refer to and access them. You need to watch out for this, be careful that you're not reusing the name of an external variable accidentally if you're writing a deeply nested function or class. For example, here we're accidentally overwriting the <code>package</code> variable in a Class function:</p>

<p><span class="csscript"></span></p>

<pre><code>package = require('./package')

class Hem
  build: -&gt;
    # Overwrites outer variable!
    package = @hemPackage.compile()

  hemPackage: -&gt;
    package.create()
</code></pre>

<p>Global variables are needed from time to time, and to create those you need to set them as properties on <code>window</code>:</p>

<p><span class="csscript"></span></p>

<pre><code>  class window.Asset
    constructor: -&gt;
</code></pre>

<p>By ensuring global variables are explicit, rather than implicit, CoffeeScript removes one of the major sources of bugs in JavaScript programs.</p>

<h2>Semicolons</h2>

<p>JavaScript does not enforce the use of semicolons in source code, so it's possible to omit them. However, behind the scenes the JavaScript compiler still needs them, so the parser automatically inserts them whenever it encounters a parse error due to a missing semicolon. In other words, it'll try to evaluate a statement without semicolons and, if that fails, tries again using semicolons.</p>

<p>Unfortunately this is a tremendously bad idea, and can actually change the behavior of your code. Take the following example, seems valid JavaScript, right?</p>

<pre><code>function() {}
(window.options || {}).property
</code></pre>

<p>Wrong, well at least according to the parser; it raises a syntax error. In case of a leading parenthesis, the parser will not insert a semicolon. The code gets transformed onto one line:</p>

<pre><code>function() {}(window.options || {}).property
</code></pre>

<p>Now you can see the issue, and why the parser is complaining. When you're writing JavaScript, you should always include semicolons after statements. Fortunately CoffeeScript gets round all this hassle by not having semicolons in its syntax. Rather the semicolons are inserted automatically (at the right places) when the CoffeeScript is compiled down to JavaScript.</p>

<h2>Reserved words</h2>

<p>Certain keywords in JavaScript are reserved for future versions of JavaScript, such as <code>const</code>, <code>enum</code> and <code>class</code>. Using these as variable names in your JavaScript programs can unpredictable results; some browsers will cope with them just fine, and others will choke. CoffeeScript neatly sidesteps this issue, by detecting if you're using a reserved keyword, and escaping it if necessary.</p>

<p>For example, let's say you were to use the reserved keyword <code>class</code> as a property on an object, your CoffeeScript might look like this:</p>

<p><span class="csscript"></span></p>

<pre><code>myObj = {
  delete: "I am a keyword!"
}
myObj.class = -&gt;
</code></pre>

<p>The CoffeeScript parser notices you're using a reserved keyword, and quotes it for you:</p>

<pre><code>var myObj;
myObj = {
  "delete": "I am a keyword!"
};
myObj["class"] = function() {};
</code></pre>

<h2>Equality comparisons</h2>

<p>The weak equality comparison in JavaScript has some confusing behavior and is often the source of confusing bugs. The example below is taken from <a href="http://bonsaiden.github.com/JavaScript-Garden/#types.equality">JavaScript Garden's equality section</a> which delves into the issue in some depth.</p>

<p><span class="csscript"></span></p>

<pre><code>""           ==   "0"           // false
0            ==   ""            // true
0            ==   "0"           // true
false        ==   "false"       // false
false        ==   "0"           // true
false        ==   undefined     // false
false        ==   null          // false
null         ==   undefined     // true
" \t\r\n"    ==   0             // true
</code></pre>

<p>The reason behind this behavior is that the weak equality coerces types automatically. I'm sure you'll agree this is all pretty ambiguous, and can lead to unexpected results and bugs.</p>

<p>The solution is to instead use the strict equality operator, which consists of three equal signs: <code>===</code>. It works exactly like the normal equality operator, but without any type coercion. It's recommended to always use the strict equality operator, and explicitly convert types if needs be.</p>

<p>CoffeeScript solves this by simply replacing all weak comparisons with strict ones, in other words converting all <code>==</code> comparators into <code>===</code>. You can't do a a weak equality comparison in CoffeeScript, and you should explicitly convert types before comparing them if necessary.</p>

<p>This doesn't mean you can ignore type coercion in CoffeeScript completely though, especially when it comes to checking the 'truthfulness' of variables during flow control. Blank strings, <code>null</code>, <code>undefined</code> and the number <code>0</code> are all coerced to <code>false</code></p>

<p><span class="csscript"></span></p>

<pre><code>alert("Empty Array")  unless [].length
alert("Empty String") unless ""
alert("Number 0")     unless 0
</code></pre>

<p>If you want to explicitly check for <code>null</code> and <code>undefined</code>, then you can use CoffeeScript's existential operator:</p>

<p><span class="csscript"></span></p>

<pre><code>alert("This is not called") unless ""?
</code></pre>

<p>The <code>alert()</code> in the previous example won't be called, as the empty string isn't equal to <code>null</code>.</p>

<h2>Function definition</h2>

<p>Oddly enough in JavaScript, functions can be defined after they're used. For example, the following runs absolutely fine, even though <code>wem</code> is defined after it's called:</p>

<pre><code>wem();
function wem() {}
</code></pre>

<p>The is because of function scope. Functions get hoisted before the programs execution and as such are available everywhere in the scope they were defined in, even if called before the actual definition in the source. The trouble is, hoisting behavior differs between browser; for example:</p>

<pre><code>if (true) {
  function declaration() {
    return "first";
  }
} else {
  function declaration() {
    return "second";
  }
}
declaration();
</code></pre>

<p>In some browsers such as Firefox, <code>declaration()</code> will return <code>"first"</code>, and in other browsers like Chrome it'll return <code>"second"</code>, even though it looks like the <code>else</code> statement is never run.</p>

<p>If you want to know more about declarative functions, then you should read <a href="http://kangax.github.com/nfe/">Juriy Zaytsev's guide</a>, where he delves into the specifics. Suffice to say, they have fairly ambiguous behavior, and can lead to problems later down the road. All things considered, It's best to steer clear of them by using function expressions instead:</p>

<pre><code>var wem = function(){};
wem();
</code></pre>

<p>CoffeeScript's approach to this is to remove declarative functions entirely, using only function expressions.</p>

<h2>Number property lookups</h2>

<p>A flaw in JavaScript's parser means that the <em>dot notation</em> on numbers is interpreted as a floating point literal, rather than a property lookup. For example, the following JavaScript will cause a syntax error:</p>

<pre><code>5.toString();
</code></pre>

<p>JavaScript's parser is looking for another Number after the dot, and so raises an <code>Unexpected token</code> error when it encounters <code>toString()</code>. The solution to this is to either use parenthesis, or add an additional dot.</p>

<pre><code>(5).toString();
5..toString();
</code></pre>

<p>Fortunately CoffeeScript's parsers is clever enough to deal with this issue by using double dot notations automatically (as in the example above) whenever you access properties on Numbers.</p>

<h1>The un-fixed parts</h1>

<p>Whilst CoffeeScript goes some length to solving some of JavaScript's design flaws, it can only go so far. As I mentioned previously, CoffeeScript's strictly limited to static analysis by design, and doesn't do any runtime checking for performance reasons. CoffeeScript uses a straight source-to-source compiler, the idea being that every CoffeeScript statement results in a equivalent JavaScript statement. CoffeeScript doesn't provide an abstraction over any of JavaScript's keywords, such as <code>typeof</code>, and as such some design flaws in JavaScript's design also apply to CoffeeScript.</p>

<p>In the previous sections we covered some design flaws in JavaScript that CoffeeScript fixes. Now let's talk about some of JavaScript's flaws that CoffeeScript can't fix.</p>

<h2>Using eval</h2>

<p>Whilst CoffeeScript removes some of JavaScript's foibles, other features are a necessary evil, you just need to be aware of their shortcomings. A case in point, is the <code>eval()</code> function. Whilst undoubtedly it has its uses, you should know about its drawbacks, and avoid it if possible. The <code>eval()</code> function will execute a string of JavaScript code in the local scope, and functions like <code>setTimeout()</code> and <code>setInterval()</code> can also both take a string as their first argument to be evaluated.</p>

<p>However, like <code>with</code>, <code>eval()</code> throws the compiler off track, and is a major performance hog. As the compiler has no idea what's inside until runtime, it can't perform any optimizations like inlining. Another concern is with security. If you give it dirty input, <code>eval</code> can easily open up your code for injection attacks. 99% of the time when you're using <code>eval</code>, there are better &amp; safer alternatives (such as square brackets).</p>

<p><span class="csscript"></span></p>

<pre><code># Don't do this
model = eval(modelName)

# Use square brackets instead
model = window[modelName]
</code></pre>

<h2>Using typeof</h2>

<p>The <code>typeof</code> operator is probably the biggest design flaw of JavaScript, simply because it's basically completely broken. In fact, it really has only one use, checking to see if a value is <code>undefined</code>.</p>

<p><span class="csscript"></span></p>

<pre><code>typeof undefinedVar is "undefined"
</code></pre>

<p>For all other types of type checking, <code>typeof</code> fails rather miserably, returning inconsistent results depending on the browser and how instances were instantiated. This isn't something that CoffeeScript can help you either, since the language uses static analysis and has no runtime type checking. You're on your own here.</p>

<p>To illustrate the problem, here's a table taken from <a href="http://bonsaiden.github.com/JavaScript-Garden/">JavaScript Garden</a> which shows some of the major inconstancies in the keyword's type checking.</p>

<pre><code>Value               Class      Type
-------------------------------------
"foo"               String     string
new String("foo")   String     object
1.2                 Number     number
new Number(1.2)     Number     object
true                Boolean    boolean
new Boolean(true)   Boolean    object
new Date()          Date       object
new Error()         Error      object
[1,2,3]             Array      object
new Array(1, 2, 3)  Array      object
new Function("")    Function   function
/abc/g              RegExp     object
new RegExp("meow")  RegExp     object
{}                  Object     object
new Object()        Object     object
</code></pre>

<p>As you can see, depending on if you define a string with quotes or with the <code>String</code> class affects the result of <code>typeof</code>. Logically <code>typeof</code> should return <code>"string"</code> for both checks, but for the latter it returns <code>"object"</code>. Unfortunately the inconstancies only get worse from there.</p>

<p>So what can we use for type checking in JavaScript? Well, luckily <code>Object.prototype.toString()</code> comes to the rescue here. If we invoke that function in the context of a particular object, it'll return the correct type. All we need to do is massage the string it returns, so we end up with the sort of string <code>typeof</code> should be returning. Here's an example implementation ported from jQuery's <code>$.type</code>:</p>

<p><span class="csscript"></span></p>

<pre><code>type = do -&gt;
  classToType = {}
  for name in "Boolean Number String Function Array Date RegExp Undefined Null".split(" ")
    classToType["[object " + name + "]"] = name.toLowerCase()

  (obj) -&gt;
    strType = Object::toString.call(obj)
    classToType[strType] or "object"

# Returns the sort of types we'd expect:
type("")         # "string"
type(new String) # "string"
type([])         # "array"
type(/\d/)       # "regexp"
type(new Date)   # "date"
type(true)       # "boolean"
type(null)       # "null"
type({})         # "object"
</code></pre>

<p>If you're checking to see if an variable has been defined, you'll still need to use <code>typeof</code> otherwise you'll get a <code>ReferenceError</code>.</p>

<p><span class="csscript"></span></p>

<pre><code>if typeof aVar isnt "undefined"
  objectType = type(aVar)
</code></pre>

<p>Or more succinctly with the existential operator:</p>

<pre><code>objectType = type(aVar?)
</code></pre>

<p>As an alternative to type checking, you can often use duck typing and the CoffeeScript existential operator together to eliminating the need to resolve an object's type. For example, let's say we're pushing a value onto an array. We could say that, as long as the 'array like' object implements <code>push()</code>, we should treat it like an array:</p>

<p><span class="csscript"></span></p>

<pre><code>anArray?.push? aValue
</code></pre>

<p>If <code>anArray</code> is an object other than an array than the existential operator will ensure that <code>push()</code> is never called.</p>

<h2>Using instanceof</h2>

<p>JavaScript's <code>instanceof</code> keyword is nearly as broken as <code>typeof</code>. Ideally <code>instanceof</code> would compare the constructor of two object, returning a boolean if one was an instance of the other. However, in reality <code>instanceof</code> only works when comparing custom made objects. When it comes to comparing built-in types, it's as useless as <code>typeof</code>.</p>

<p><span class="csscript"></span></p>

<pre><code>new String("foo") instanceof String # true
"foo" instanceof String             # false
</code></pre>

<p>Additionally, <code>instanceof</code> also doesn't work when comparing object from different frames in the browser. In fact, <code>instanceof</code> only returns a correct result for custom made objects, such as CoffeeScript classes.</p>

<p><span class="csscript"></span></p>

<pre><code>class Parent
class Child extends Parent

child = new Child
child instanceof Child  # true
child instanceof Parent # true
</code></pre>

<p>Make sure you only use it for your own objects or, even better, stick clear of it.</p>

<h2>Using delete</h2>

<p>The <code>delete</code> keyword can only safely be used for removing properties inside objects.</p>

<p><span class="csscript"></span></p>

<pre><code>anObject = {one: 1, two: 2}
delete anObject.one
anObject.hasOwnProperty("one") # false
</code></pre>

<p>Any other use, such as deleting variables or function's won't work.</p>

<p><span class="csscript"></span></p>

<pre><code>aVar = 1
delete aVar
typeof Var # "integer"
</code></pre>

<p>It's rather peculiar behavior, but there you have it. If you want to remove a reference to a variable, just assign it to <code>null</code> instead.</p>

<p><span class="csscript"></span></p>

<pre><code>aVar = 1
aVar = null
</code></pre>

<h2>Using parseInt</h2>

<p>JavaScript's <code>parseInt()</code> function can return unexpected results if you pass a string to it without informing it of the proper base. For example:</p>

<pre><code># Returns 8, not 10!
parseInt('010') is 8
</code></pre>

<p>Always pass a base to the function to make it work correctly:</p>

<pre><code># Use base 10 for the correct result
parseInt('010', 10) is 10
</code></pre>

<p>This isn't something CoffeeScript can do for you; you'll just have to remember to always specify a base when using <code>parseInt()</code>.</p>

<h2>Strict mode</h2>

<p>Strict mode is a new feature of ECMAScript 5 that allows you to run a JavaScript program or function in a <em>strict</em> context. This strict context throws more exceptions and warnings than the normal context, giving developers some indication when they're straying from best practices, writing un-optimizable code or making common mistakes. In other words, strict mode reduces bugs, increases security, improves performance and eliminates some difficult to use language features. What's not to like?</p>

<p>Strict mode is currently supported in the following browsers:</p>

<ul>
<li>Chrome >= 13.0</li>
<li>Safari >= 5.0</li>
<li>Opera >= 12.0</li>
<li>Firefox >= 4.0</li>
<li>IE >= 10.0</li>
</ul>


<p>Having said that, strict mode is completely backwards compatible with older browsers. Programs using it should run fine in either a strict or normal context.</p>

<h3>Strict mode changes</h3>

<p>Most of the changes strict mode introduces pertain to JavaScript's syntax:</p>

<ul>
<li>Errors on duplicate property and function argument names</li>
<li>Errors on incorrect use of the <code>delete</code> operator</li>
<li>Access to <code>arguments.caller</code> &amp; <code>arguments.callee</code> throws an error (for performance reasons)</li>
<li>Using the <code>with</code> operator will raise a syntax error</li>
<li>Certain variables such as <code>undefined</code> are no longer writeable</li>
<li>Introduces additional reserved keywords, such as <code>implements</code>, <code>interface</code>, <code>let</code>, <code>package</code>, <code>private</code>, <code>protected</code>, <code>public</code>, <code>static</code>, and <code>yield</code></li>
</ul>


<p>However, strict mode also changes some runtime behavior:</p>

<ul>
<li>Global variables are explicit (<code>var</code> always required). The global value of <code>this</code> is <code>undefined</code>.</li>
<li><code>eval</code> can't introduce new variables into the local context</li>
<li>Function statements have to be defined before they're used (previously functions could be <a href="http://whereswalden.com/2011/01/24/new-es5-strict-mode-requirement-function-statements-not-at-top-level-of-a-program-or-function-are-prohibited/">defined anywhere</a>).</li>
<li><code>arguments</code> is immutable</li>
</ul>


<p>CoffeeScript already abides by a lot of strict mode's requirements, such as always using <code>var</code> when defining variables, but it's still very useful to enable strict mode in your CoffeeScript programs. Indeed, CoffeeScript is taking this a step further and in <a href="https://github.com/jashkenas/coffee-script/issues/1547">future versions</a> will check a program's compliance to strict mode at compile time.</p>

<h3>Strict mode usage</h3>

<p>All you need to do to enable strict checking is start your script or function with the following string:</p>

<p><span class="csscript"></span></p>

<pre><code>-&gt;
  "use strict"

  # ... your code ...
</code></pre>

<p>That's it, just the <code>'use strict'</code> string. Couldn't be simpler and it's completely backwards compatible. Let's take a look at strict mode in action. The following function will raise a syntax error in strict mode, but run fine in the usual mode:</p>

<p><span class="csscript"></span></p>

<pre><code>do -&gt;
  "use strict"
  console.log(arguments.callee)
</code></pre>

<p>Strict mode has removed access to <code>arguments.caller</code> &amp; <code>arguments.callee</code> as they're major performance hogs, and is now throwing syntax errors whenever they're used.</p>

<p>There's a particular gotcha you should look out for when using strict mode, namely creating global variables with <code>this</code>. The following example will throw a <code>TypeError</code> in strict mode, but run fine in a normal context, creating a global variable:</p>

<p><span class="csscript"></span></p>

<pre><code>do -&gt;
  "use strict"
  class @Spine
</code></pre>

<p>The reason behind this disparity is that in strict mode <code>this</code> is <code>undefined</code>, whereas normally it refers to the <code>window</code> object. The solution to this is to explicitly set global variables on the <code>window</code> object.</p>

<p><span class="csscript"></span></p>

<pre><code>do -&gt;
  "use strict"
  class window.Spine
</code></pre>

<p>Whilst I recommend enabling strict mode, but it's worth noting that strict mode doesn't enable any new features that aren't ready possible in JavaScript, and will actually slow down your code a bit by having the VM do more checks at runtime. You may want to develop with strict mode, and deploy to production without it.</p>

<h2>JavaScript Lint</h2>

<p><a href="http://www.javascriptlint.com/">JavaScript Lint</a> is a JavaScript code quality tool, and running your programs through it is a great way of improving code quality and best practices. The project was based on a similar tool called <a href="http://www.jslint.com">JSLint</a>. Check out JSLint's site for a <a href="http://www.jslint.com/lint.html">great list</a> of issues that it checks for, including global variables, missing semicolons and weak equality comparisons.</p>

<p>The good news is that CoffeeScript already 'lints' all of its output, so CoffeeScript generated JavaScript is already JavaScript Lint compatible. In fact, the <code>coffee</code> tool has support for a <code>--lint</code> option:</p>

<pre><code>coffee --lint index.coffee
  index.coffee: 0 error(s), 0 warning(s)
</code></pre>

  </div>
</div>
</body>
</html>