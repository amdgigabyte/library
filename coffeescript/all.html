<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>The Little Book on CoffeeScript - Introduction</title>
<link rel="stylesheet" href="site/site.css" type="text/css" charset="utf-8">
<link rel="stylesheet" href="site/highlight.css" type="text/css" charset="utf-8">
<script src="site/jquery.js" type="text/javascript" charset="utf-8"></script>      
<script src="site/highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="site/coffee-script.js" type="text/javascript" charset="utf-8"></script>
<script src="site/preview.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
  hljs.initHighlightingOnLoad();
</script>
</head>
<body>
<div id="container">
  <header>
    <h1><a href="index.html">The Little Book on CoffeeScript</a></h1>
  </header>
  
  <div id="content">
    <div class="back"><a href="index.html">&laquo; 回到章节列表</a></div>


<h1>什么是CoffeeScript?</h1>

<p><a href="http://coffeescript.org">CoffeeScript</a> 是一门可以被编译成JavaScript的小型语言. 它借鉴了Ruby和Python的语法, 并借鉴了它们的一些特性. 本书致力于帮你学习CoffeeScript, 理解他的最佳实践并能够制作优质的客户端程序. 这本书很短小,只有五章, 但这也正好映衬了CoffeeScript这门短小的语言.</p>

<p>本书是完全开源的, 由 <a href="http://alexmaccaw.co.uk">Alex MacCaw</a> (or <a href="http://twitter.com/maccman">@maccman</a>) 编写并得到了 <a href="https://github.com/dxgriffiths">David Griffiths</a>, <a href="http://github.com/satyr">Satoshi Murakami</a>和 <a href="https://github.com/jashkenas">Jeremy Ashkenas</a>的支持.</p>

<p>如果你有建议或者发现书写错误, 别犹豫，在本书的<a href="https://github.com/arcturo/library">GitHub page</a>发起一个issue. 读者们可以也会对<a href="http://oreilly.com/catalog/9781449307530/">JavaScript Web Applications by O'Reilly</a>这本书比较感兴趣, 这是我写的一本介绍JavaScript富应用和客户端状态管理的书.</p>

<p>那我们现在就开始吧; 为什么写CoffeeScript会优于写纯JavaScript? 首先, 你可一些更少的代码 - CoffeeScript语法非常的精简明了, 并且把空格也当作了语法的一部分. 从我自己的经验来说，它相比纯JavaScript至少减少了三分之一到一半的代码. 并且, CoffeeScript拥有一些整洁的特性, 例如array comprehensions, prototype aliases 以及 减少了你代码量的类编写.</p>

<p>更重要的是, JavaScript的一些<a href="http://bonsaiden.github.com/JavaScript-Garden/">古怪的特性</a>经常会困扰一些经验不足的程序员. CoffeeScript巧妙的避开了这些问题，而只暴露JavaScript中发挥真正作用的那部分, 如此解决了这门语言中许多的问题.</p>

<p>CoffeeScript <em>不是</em> JavaScript 的子集, 因此虽然你可以在CoffeeScript中使用外部库而没有做对应的转换, 你在把它编译成JavaScript的时候还是会报错. 编译器会静态的把CoffeeScript的代码翻译成它自己对应的JavaScript副本, 而不是在代码运行期进行转换.</p>

<p>学习前我们先来看看一些常见的谬误. 在写 CoffeeScript 之前你需要了解 JavaScript, 因为运行期的错误需要你的JavaScript知识. 话说回来, 运行期的错误是非常明显的, 到目前为止我还没有觉得把JavaScript报错对应到CoffeeScript是一大麻烦事. 我听说过的第二个关于CoffeeScript的问题是运行速度; 举个例子. 通过 CoffeeScript 编译器生成的代码会比使用纯 JavaScript 编写的代码慢. 但是在实践中, 这并不是一个问题. CoffeeScript 跑得并不慢, 甚至于相比手写的 JavaScript 会更快.</p>

<p>那么使用 CoffeeScript 的劣势有哪些呢? 我想主要的就是它在你和JavaScript之间又增加一步编译. CoffeeScript 通过生成清晰可读的JavaScript代码以及通过服务端自动编译来尽可能的解决这个问题. 另一个劣势, 和别的新新语言一样, CoffeeScript的社区还是很小, 并且目前为止要找一个熟悉这么语言的同伴可能会很困难. 虽然如此CoffeeScript 还是在快速扩张并且它的IRC列表维护的很好; 你有任何的问题都可以得到及时的回应.</p>

<p>CoffeeScript 并不仅仅限于浏览器端的开发, 它在服务器端的JavaScript实现, 例如 <a href="http://nodejs.org/">Node.js</a>上面也有优异的表现. 此外, CoffeeScript正被广泛的使用和积累, 例如在 Rails 3.1 已经默认支持. 现在绝对是跳上CoffeeScript这趟快车的最佳时机. 现在学习这门语言投入的时间都将会在以后被偿还.</p>

<h2>初始化安装</h2>

<p>开始使用CoffeeScript最简单的方式就是在浏览器中使用它. 访问 <a href="http://coffeescript.org">http://coffeescript.org</a> 然后点击 <em>Try CoffeeScript</em> tab. 该站点使用了一个浏览器版本的CoffeeScript编译器，并且可以转换你在左侧面板输入的CoffeeScript到右侧的JavaScript面板中.</p>

<p>你也可以使用<a href="http://js2coffee.org/">js2coffee</a> 项目把JavaScript反转回CoffeeScript, 这在把JavaScript项目迁移至Coffee时非常有用.</p>

<p>事实上, 你可以通过引入<a href="http://jashkenas.github.com/coffee-script/extras/coffee-script.js">此脚本</a> 来使用这个工作于浏览器的CoffeeScript编译器, 并使用对应的 <code>type</code> 来标识 CoffeeScript脚本.</p>

<pre><code>&lt;script src="http://jashkenas.github.com/coffee-script/extras/coffee-script.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;
&lt;script type="text/coffeescript"&gt;
  # Some CoffeeScript
&lt;/script&gt;
</code></pre>

<p>不过，在实际的应用中，你显然不期望在运行期把CoffeeScript在客户端进行实时的解析.而CoffeeScript也正好提供了一个<a href="http://nodejs.org">Node.js</a>的编译器来预处理CoffeeScript文件.</p>

<p>要安装这个编译器, 首先要确保你安装了最新版本的 <a href="http://nodejs.org">Node.js</a>, 以及 <a href="http://npmjs.org/">npm</a> (Node包管理). 然后就可以使用npm来安装CoffeeScript:</p>

<pre><code>npm install -g coffee-script
</code></pre>

<p>通过加上 -g 可以是你直接使用<code>coffee</code>命令. 当你直接在命令行敲入这个命令，你将进入一个CoffeeScript的命令行模式,在里面可以输入并执行一些CoffeeScript语句. 如果要预处理CoffeeScript文件的话, 要在命令后面再加上 <code>--compile</code> 的选项.</p>

<pre><code>coffee --compile my-script.coffee
</code></pre>

<p>如果没有指定 <code>--output</code> 选项, CoffeeScript 编译器会生成一个和coffee文件同名的 JavaScript 文件, 在这个例子中就是 <code>my-script.js</code>. 如果有同名的js存在,则这个js会被覆盖, 因此要小心无意中覆盖了你原有的JavaScript文件. 如果要完整的了解命令行的各个选项，你需要加上一个 <code>--help</code> 选项.</p>

<p>正如你已经看到的，CoffeeScript文件默认的扩展名是<code>.coffee</code>. 这将可以使像<a href="http://macromates.com/">TextMate</a> 这样的编辑器使用合适的语法高亮来显示代码. 默认, TextMate 并不支持 CoffeeScript 语法, 但是你可以安装 <a href="https://github.com/jashkenas/coffee-script-tmbundle">插件</a> 来解决.</p>

<p>如果你觉得所有的编译过程看起来有些不方便, 那是因为它的确是这样的. 我们将通过自动编译CoffeeScript文件来解决这些问题, 不过首先让我们来看看CoffeeScript的语法.</p>

  </div>
</div>
</body>
</html><!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>The Little Book on CoffeeScript - Syntax</title>
<link rel="stylesheet" href="site/site.css" type="text/css" charset="utf-8">
<link rel="stylesheet" href="site/highlight.css" type="text/css" charset="utf-8">
<script src="site/jquery.js" type="text/javascript" charset="utf-8"></script>      
<script src="site/highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="site/coffee-script.js" type="text/javascript" charset="utf-8"></script>
<script src="site/preview.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
  hljs.initHighlightingOnLoad();
</script>
</head>
<body>
<div id="container">
  <header>
    <h1><a href="index.html">The Little Book on CoffeeScript</a></h1>
  </header>
  
  <div id="content">
    <div class="back"><a href="index.html">&laquo; 返回章节列表</a></div>


<h1>CoffeeScript 语法</h1>

<p>首先,在我们开始本章学习前,我还是要重申一下,CoffeeScript 和 JavaScript在语法上面是相对独立的，CoffeeScript不是JavaScript的子集, 因此一些JavaScript的关键字，如<code>function</code>、<code>var</code> 不是合法的,直接使用会导致抛错.如果你是在写CoffeeScript,那么它就应该是纯CoffeeScript,而不应该是两种语言的混合体.</p>

<p>为什么CoffeeScript不是一个子集合？一个很好的事实是在CoffeeScript中空格是有重要含义的. And, once that decision's been made, the team decided you might as well go the full hog and deprecate some JavaScript keywords and features in the name of simplicity and in an effort to reduce many commonly occurring bugs. 为了达到简洁并能够减少一些常见bug的出现，CoffeeScript的维护团队决定摒弃一些JavaScript的关键字和特性.（这句话感觉有些问题还）</p>

<p>让我兴奋的是，通过元排序的方式, CoffeeScript的编译器本身就是由CoffeeScript编写的. 这仿佛解决了一个鸡生蛋还是蛋生鸡的问题.</p>

<p>好, 我们首先来说明一下最基本的问题. 在CoffeeScript中没有分号,分号都会在编译后被自动的加上.分号的可以引起很多奇怪的<a href="http://bonsaiden.github.com/JavaScript-Garden/#core.semicolon">行为</a>，这些旺旺会在JavaScript社区引起了很多的争论.不管怎么说, CoffeeScript 在它的语法中去掉了分号而是在需要时再加上从而解决了这一系列问题.</p>

<p>CoffeeScript的注释是和Ruby的注释形式一样的, 在行首加上一个井号即可.</p>

<pre><code># A comment
</code></pre>

<p>多行的注释同样支持, 并且这些注释也会被带到编译后的js中. 注释的代码被三个井号的对所包围.</p>

<p><span class="csscript"></span></p>

<pre><code>###
  A multiline comment, perhaps a LICENSE.
###
</code></pre>

<p>正如我之前提到的, 空白在 CoffeeScript 中作用显著. 实际运用中, 你可以用一个制表符来代替块结构 (<code>{}</code>) . 这一点沿袭了Python的语法, 这样能够确保你的代码是以一种优良的方式被格式化显示, 否则，代码可能不能被编译!</p>

<h2>变量 和 作用域</h2>

<p>CoffeeScript 修正了 JavaScript 中最容易产生问题的一点, 全局变量. 在 JavaScript 中, 在申明变量是往往很容易遗漏 <code>var</code> 从而产生了全局变量. CoffeeScript 去掉了全局变量从而解决了这一问题. 事实上, CoffeeScript 通过一个匿名函数来包裹脚本, 保证了本地作用域, 并且会默认对所有的变量申明都加上 <code>var</code>. 举个例子, 就像这样一个 CoffeeScript 中的变量赋值:</p>

<p><span class="csscript"></span></p>

<pre><code>myVariable = "test"
</code></pre>

<p>注意到代码部分右上角的深灰色按钮了么？ 点击它, 代码会在CoffeeScript和编译后的JavaScript之间切换. 这些都是在页面中实时生成的, 你可以放心这些编译结果都是正确的.</p>

<p>可以看到, 赋值的变量作用域保持在了本地, 这也杜绝了产生全局变量的可能. CoffeeScript 还做了更进一步处理, 使得要覆盖高级别的变量变得更为困难. 这很好的避免了一些常见的JavaScript开发的错误=.</p>

<p>然而, 有时候创建全局变量是很有用的. 这时你可以在全局对象(如浏览器中的<code>window</code>)上面挂载变量或者使用以下的形式:</p>

<p><span class="csscript"></span></p>

<pre><code>exports = this
exports.MyVariable = "foo-bar"
</code></pre>

<p>在底层的上下文中，<code>this</code> 指向了全局对象, 通过创建一个叫 <code>exports</code> 的本地变量，你可以很明确的告诉别人脚本中的哪些变量是全局创建的. 并且, 他为 CommonJS 模块铺平了道路, 关于CommonJS我们将在后面讲述.</p>

<h2>函数</h2>

<p>CoffeeScript 相当累赘的 <code>function</code> 语句, 而用一个 <code>-&gt;</code> 来代替它. 函数申明可以是一行或者是多行. 最后的一个表达式会作为函数的返回结果. 换句话说, 你根本不需要 <code>return</code> 语句除非你是想在函数内更早的地方返回函数.</p>

<p>了解了这些, 我们来看一个例子:</p>

<p><span class="csscript"></span></p>

<pre><code>func = -&gt; "bar"
</code></pre>

<p>你可以发现在编译的结果中, <code>-&gt;</code> 被转化成了 <code>function</code> 语句, 并且字符串 <code>"bar"</code> 被自动作为结果返回了.</p>

<p>之前已经提到, 我们肯定会用到多行的函数申明, 只要我们正确地缩进.</p>

<p><span class="csscript"></span></p>

<pre><code>func = -&gt;
  # An extra line
  "bar"
</code></pre>

<h3>函数参数</h3>

<p>那么如何指定函数的参数呢? CoffeeScript 允许你在函数的箭头前面指定函数的参数.</p>

<p><span class="csscript"></span></p>

<pre><code>times = (a, b) -&gt; a * b
</code></pre>

<p>CoffeeScript 还支持参数的默认值, 例子:</p>

<p><span class="csscript"></span></p>

<pre><code>times = (a = 1, b = 2) -&gt; a * b
</code></pre>

<p>你也可以使用省略号 <code>...</code> 来允许接受多个参数</p>

<p><span class="csscript"></span></p>

<pre><code>sum = (nums...) -&gt; 
  result = 0
  nums.forEach (n) -&gt; result += n
  result
</code></pre>

<p>在上面的例子中, <code>nums</code> 作为一个包含所有参数的参数数组传递给函数. 它不是一个 <code>arguments</code> 对象, 而是一个真正的数组, 因此当你要操作它时, 你不需要 <code>Array.prototype.splice</code> 或是 <code>jQuery.makeArray()</code> 多做一次处理.</p>

<p><span class="csscript"></span></p>

<pre><code>trigger = (events...) -&gt;
  events.splice(1, 0, this)
  this.constructor.trigger.apply(events)
</code></pre>

<h3>函数调用</h3>

<p>在JavaScript中通过<code>()</code>, <code>apply()</code> 或者 <code>call()</code>可以调用函数. 而在CoffeeScript中, 则类似 Ruby, CoffeeScript 中如果函数传递了至少一个参数,那么他就会执行.</p>

<p><span class="csscript"></span></p>

<pre><code>a = "Howdy!"

alert a
# Equivalent to:
alert(a)

alert inspect a
# Equivalent to:
alert(inspect(a))
</code></pre>

<p>虽然括号在调用是可选的, 但我还是强烈建议加上，这样可以明显的区分哪些是函数以及他们的参数. 在最后的这个例子中, 对于函数 <code>inspect</code>, 我建议至少要在 <code>inspect</code> 外面包上括号.</p>

<p><span class="csscript"></span></p>

<pre><code>alert inspect(a)
</code></pre>

<p>如果在调用时你不传递任何的参数, CoffeeScript将没有办法区分你是要立即调用这个函数还是说把它作为一个变量. 在这方面, CoffeeScript的行为与 Ruby 就不一样了, Ruby总是会调用函数的引用, 而这更像是 Python 的语法. 这样子做确保了在 CoffeeScript 程序中不会轻易产生错误, 因此当你需要调用一个函数而不打算传参给它的时候记得要保留括号.</p>

<h3>函数上下文</h3>

<p>上下文的变化在JavaScript中是很频繁的一件事情, 尤其是在事件回调的时候,因此COffeeScript提供了一些辅助功能特性来解决这类问题. 一个特性是<code>-&gt;</code> 的变种 <code>=&gt;</code></p>

<p>使用 <code>=&gt;</code> 代替 <code>-&gt;</code> 可以保证函数的上下文会始终指向本地的上下文. 例如:</p>

<p><span class="csscript"></span></p>

<pre><code>this.clickHandler = -&gt; alert "clicked"
element.addEventListener "click", (e) =&gt; this.clickHandler(e)
</code></pre>

<p>你需要这么做的原因是,<code>addEventListener()</code> 的回调是在 <code>element</code> 的上下文中执行的, 即 <code>this</code> 指向 <code>element</code> . 如果你要保持 <code>this</code> 始终等于本地上下文, 并省略类似 <code>self = this</code> 这样的步骤, <code>=&gt;</code> 正好满足你的需求.</p>

<p>这种绑定的思想借鉴自jQuery的 <a href="http://api.jquery.com/jQuery.proxy/"><code>proxy()</code></a> 以及 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind">ES5's</a> <code>bind()</code> 函数.</p>

<h2>对象字面量 &amp; 数组定义</h2>

<p>在JavaScript中，可以通过一对包裹key/value的大括号来申明对象字面量. 然而, 正如对函数声明的改进, CoffeeScript 把大括号作为了可选的. 事实上, 你甚至可以使用缩进和换行的方式来替代逗号分隔.</p>

<p><span class="csscript"></span></p>

<pre><code>object1 = {one: 1, two: 2}

# Without braces
object2 = one: 1, two: 2

# Using new lines instead of commas
object3 = 
  one: 1
  two: 2

User.create(name: "John Smith")
</code></pre>

<p>类似地, 数组的逗号也可以用空格来替代, 不过中括号 (<code>[]</code>) 还是要保留的.</p>

<p><span class="csscript"></span></p>

<pre><code>array1 = [1, 2, 3]

array2 = [
  1
  2
  3
]

array3 = [1,2,3,]
</code></pre>

<p>从上面的例子你可以看到, CoffeeScript 会去掉 <code>array3</code>的最后一个逗号, 这也是经常会引起跨浏览器问题的一个原因.</p>

<h2>流控制</h2>

<p>在流控制语句中, CoffeeScript 把括号作为了可选, 但还是保留了<code>if</code> 和 <code>else</code>关键字.</p>

<p><span class="csscript"></span></p>

<pre><code>if true == true
  "We're ok"

if true != true then "Panic"

# Equivalent to:
#  (1 &gt; 0) ? "Ok" : "Y2K!"
if 1 &gt; 0 then "Ok" else "Y2K!"
</code></pre>

<p>从上面你可以发现, 如果 <code>if</code> 语句是单行的, 你还需要加上一个 <code>then</code> 关键字, 这样CoffeeScript可以知道语句块从何处开始. 要指出的是条件操作符 (<code>?:</code>) 并不被CoffeeScrit支持, 你可以使用单行 <code>if/else</code> 代替.</p>

<p>CoffeeScript 还在<code>if</code>语句中引入了一个Ruby的语法特性.</p>

<p><span class="csscript"></span></p>

<pre><code>alert "It's cold!" if heat &lt; 5
</code></pre>

<p>除了使用<code>!</code>来表示非, 你还可以使用<code>not</code> 关键字. 这也在某种程度上面增加了程序的可读性.</p>

<p><span class="csscript"></span></p>

<pre><code>if not true then "Panic"
</code></pre>

<p>在上面的例子中, 我们还可以使用 CoffeeScript的 <code>unless</code> 语句, 他的逻辑与 <code>if</code> 正好相反.</p>

<p><span class="csscript"></span></p>

<pre><code>unless true
  "Panic"
</code></pre>

<p>类似 <code>not</code>, CoffeeScript 还加上了 <code>is</code> 语句, 它等同于 <code>===</code>.</p>

<p><span class="csscript"></span></p>

<pre><code>if true is 1
  "Type coercion fail!"
</code></pre>

<p>此外, 如果要替代 <code>is not</code>, 你还可以使用 <code>isnt</code>.</p>

<pre><code>if true isnt true
  alert "Opposite day!"
</code></pre>

<p>你可能已经注意到上面的例子中, CoffeeScript 把 <code>==</code> 操作符转化为 <code>===</code> 同样把 <code>!=</code> 转化为 <code>!==</code>. 这是我个人最喜欢也是最简单的语言特性之一. 为什么要这么做呢? 老实说 JavaScript 的类型转换有点古怪, 要对比不同的变量必须要先经过类型转换, 这就可能会引起一些奇怪的问题或是bug. 这一块在第7章会有重点讨论.</p>

<h2>字符串插值</h2>

<p>CoffeeScript 把 Ruby 风格的字符串插值带到了 JavaScript中. 在双引号中可以包含 <code>#{}</code> 标签, 里面可以包含一些表达式的值被插入到字符串中.</p>

<p><span class="csscript"></span></p>

<pre><code>favourite_color = "Blue. No, yel..."
question = "Bridgekeeper: What... is your favourite color?
            Galahad: #{favourite_color}
            Bridgekeeper: Wrong!
            "
</code></pre>

<p>从上面的例子中你可以看出, 即使不加 <code>+</code> 号, 多行文本也是支持的.</p>

<h2>循环 和 Comprehensions（内含？）</h2>

<p>JavaScript中的数组的迭代使用了一套非常古老的语法, 这让人联想到了C语言而不是一门面向对象的语言. ES5引入了 <code>forEach()</code> 函数以改变这一现状,但是对于每次的迭代依旧需要一次函数调用,这也导致了执行速度的降低. 针对这一点, CoffeeScript 通过一种美妙的语法做了对应的处理:</p>

<p><span class="csscript"></span></p>

<pre><code>for name in ["Roger", "Roderick", "Brian"]
  alert "Release #{name}"
</code></pre>

<p>如果你要得到当前的循环index, 只需要再多传递一个参数:</p>

<p><span class="csscript"></span></p>

<pre><code>for name, i in ["Roger the pickpocket", "Roderick the robber"]
  alert "#{i} - Release #{name}"
</code></pre>

<p>你也可以使用后缀的形式在一行内做循环.</p>

<p><span class="csscript"></span></p>

<pre><code>release prisoner for prisoner in ["Roger", "Roderick", "Brian"]
</code></pre>

<p>如果你熟悉Python的语法, 你可以过滤这些结果:</p>

<p><span class="csscript"></span></p>

<pre><code>prisoners = ["Roger", "Roderick", "Brian"]
release prisoner for prisoner in prisoners when prisoner[0] is "R" 
</code></pre>

<p>你也可以利用自己遍历对象属性的知识来遍历对象, 遍历时要把<code>in</code> 换成<code>of</code>.</p>

<p><span class="csscript"></span></p>

<pre><code>names = sam: seaborn, donna: moss
alert("#{first} #{last}") for first, last of names
</code></pre>

<p>CoffeeScript提供的唯一一个低级别的循环是 <code>while</code> 循环.这和JavaScript中的很相似.不过在CoffeeScript中while多提供了一个返回值, 包含了一个结果的数组.这就类似于<code>Array.prototype.map()</code>函数的功能.</p>

<p><span class="csscript"></span></p>

<pre><code>num = 6
minstrel = while num -= 1
  num + " Brave Sir Robin ran away"
</code></pre>

<h2>数组</h2>

<p>CoffeeScript 在处理数组切割时借鉴了Ruby使用区间的思想. 一个区间的创建需要两个数值, 分别代表区间的初始位置和最终位置, 他们被 <code>..</code> 或是 <code>...</code>所分隔. 如果一个区间没有任何的前缀, CoffeeScript会把它扩充成一个数组.</p>

<p><span class="csscript"></span></p>

<pre><code>range = [1..5]
</code></pre>

<p>然而,如果区间指定后立即被赋予一个变量, CoffeeScript会使用<code>slice()</code> 方法对数组进行转换.</p>

<p><span class="csscript"></span></p>

<pre><code>firstTwo = ["one", "two", "three"][0..1]
</code></pre>

<p>在上面的例子中, 通过区间返回了一个新的数组,它包含了原数组的前两个元素. 你也可以利用这种语法来用另一个数组替换当前数组的一部分.</p>

<p><span class="csscript"></span></p>

<pre><code>numbers = [0..9]
numbers[3..5] = [-3, -4, -5]
</code></pre>

<p>灵活的是,JavaScript允许你使用<code>slice</code>方法来切割字符串, 因此你可以使用字符串的区间来返回一个子字符串.</p>

<p><span class="csscript"></span></p>

<pre><code>my = "my string"[0..2]
</code></pre>

<p>在JavaScript中要检查一个值是否存在于一个数组总是一件麻烦事,我想部分原因是 <code>indexOf()</code> 在全浏览器中的并不是支持的很完美(我想说的是IE).
CoffeeScript通过 <code>in</code> 运算符解决了这一问题.以下是例子.</p>

<p><span class="csscript"></span></p>

<pre><code>words = ["rattled", "roudy", "rebbles", "ranks"]
alert "Stop wagging me" if "ranks" in words 
</code></pre>

<h2>别名 &amp; “存在”操作符</h2>

<p>CoffeeScript 的语法中包含了一些实用的别名,他们节省了你的输入. 其中一个是 <code>@</code>, 他表示的是 <code>this</code>.</p>

<p><span class="csscript"></span></p>

<pre><code>@saviour = true
</code></pre>

<p>另一个是 <code>::</code>, 他是 <code>prototype</code> 的别名</p>

<p><span class="csscript"></span></p>

<pre><code>User::first = -&gt; @records[0]
</code></pre>

<p>在JavaScript通过 <code>if</code> 来检查 <code>null</code> 是很普遍的事情, 但是空字符串和 0 也会被转换成<code>false</code>, 这使得检查往往出现一些疏漏. CoffeeScript 的"存在"操作符 <code>?</code> 只会在一个变量是<code>null</code> 或者是<code>undefined</code> 返回true, 这有点类似于 Ruby的 <code>nil</code>.</p>

<p><span class="csscript"></span></p>

<pre><code>praise if brian?
</code></pre>

<p>你也可以用它来替代 <code>||</code> 操作符:</p>

<p><span class="csscript"></span></p>

<pre><code>velocity = southern ? 40
</code></pre>

<p>如果你是要在获取属性之前做一个 <code>null</code> 的检查. 你可以把"存在"操作符放在属性的访问之前. 这有点类似于Active Support的<a href="http://guides.rubyonrails.org/active_support_core_extensions.html#try"><code>try</code></a> 方法.</p>

<p><span class="csscript"></span></p>

<pre><code>blackKnight.getLegs()?.kick()
</code></pre>

<p>类似的你可以把<code>?</code>放在括号的前面来检查一个属性是否是一个方法并且可被调用.如果这个属性不存在或者并非是一个方法,那么他将不会被执行.
Similarly you can check that a property is actually a function, and callable, by placing the existential operator right before the parens. If the property doesn't exist, or isn't a function, it simply won't get called.</p>

<p><span class="csscript"></span></p>

<pre><code>blackKnight.getLegs().kick?()
</code></pre>

  </div>
</div>
</body>
</html><!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>The Little Book on CoffeeScript - Classes</title>
<link rel="stylesheet" href="site/site.css" type="text/css" charset="utf-8">
<link rel="stylesheet" href="site/highlight.css" type="text/css" charset="utf-8">
<script src="site/jquery.js" type="text/javascript" charset="utf-8"></script>      
<script src="site/highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="site/coffee-script.js" type="text/javascript" charset="utf-8"></script>
<script src="site/preview.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
  hljs.initHighlightingOnLoad();
</script>
</head>
<body>
<div id="container">
  <header>
    <h1><a href="index.html">The Little Book on CoffeeScript</a></h1>
  </header>
  
  <div id="content">
    <div class="back"><a href="index.html">&laquo; 返回章节列表</a></div>


<h1>类</h1>

<p>类在javascritp中发挥的功效很大，就像对付吸血鬼的大蒜头一样，不过话说回来，如果你有这种想法，你很可能不会去看一本coffeescript的书。然而，类在javascript无非只是表现的和它在别的语言里面一样的作用，而coffeescript提供了更好的抽象.</p>

<p>CoffeeScript使用了javascript原生的原形来创建类，并且添加了一些静态属性和保持作用域上的语法糖。而这一切都通过 <code>class</code> 关键字提供给开发者</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
</code></pre>

<p>在上面的例子中, <code>Animal</code> 是类名,我们可以用这个类目来创建变量.CoffeeScript支持构造函数，这意味着你可以通过<code>new</code>操作符来生成实例.</p>

<p><span class="csscript"></span></p>

<pre><code>animal = new Animal
</code></pre>

<p>定义构造函数非常简单，只需定义一个 <code>constructor</code> 函数.这就像我们使用Ruby的 <code>initialize</code> 或者 Python 的 <code>__init__</code>.</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  constructor: (name) -&gt;
    @name = name
</code></pre>

<p>事实上，CoffeeScript提供了一种设定实例属性的缩写方式。只需要在参数前加上<code>@</code>, CoffeeScript会自动的在构造函数中设定实例的属性,事实上，这个缩写方式也适用于普通的类之外的函数。下面的这个例子和我们之前手动设定实例属性的例子是等价的.</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  constructor: (@name) -&gt;
</code></pre>

<p>正如你期望的，任何在初始化过程中传入的参数都会被传入构造函数.</p>

<p><span class="csscript"></span></p>

<pre><code>animal = new Animal("Parrot")
alert "Animal is a #{animal.name}"
</code></pre>

<h2>实例属性</h2>

<p>给一个类添加额外的实例方法非常的简单。它与对一个对象添加属性的语法一样。只是正确的把方法添加在class之中.</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  price: 5

  sell: (customer) -&gt;

animal = new Animal
animal.sell(new Customer)
</code></pre>

<p>作用域的改变在Javascript中非常普遍，在之前的语法章节，我们谈及了CoffeeScript可以通过 <code>=&gt;</code> 锁定 <code>this</code> 的值到一个固定的执行上下文上面。这就确保了不论函数在什么作用域下运行，他总会在他创建时的执行上下文下执行.</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  price: 5

  sell: =&gt;
    alert "Give me #{@price} shillings!"

animal = new Animal
$("#sell").click(animal.sell)
</code></pre>

<p>上面的例子已经说明，this在事件回调中非常有用。通常来说, <code>sell()</code>函数只会在 <code>#sell</code> 的元素的作用域下面执行。不过通过对<code>sell()</code>函数使用<code>=&gt;</code> 符，我们可以保证它的作用域一直不变。并且 <code>this.price</code> 始终等于 <code>5</code>.</p>

<h2>静态属性</h2>

<p>那么如何定义类的方法(静态方法)呢？很简单，在一个类的定义体中，<code>this</code>指向这个类对象.换句话说,你可以直接在<code>this</code>上面设置静态属性(类属性).</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  this.find = (name) -&gt;      

Animal.find("Parrot")
</code></pre>

<p>你可能还记得，CoffeeScript通过<code>@</code>符来引用 <code>this</code>，这样你能更简洁的编写静态方法:</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  @find: (name) -&gt;

Animal.find("Parrot")
</code></pre>

<h2>继承和超类</h2>

<p>如果没有继承的机制,类的存在也就没有真正的意义, CoffeeScript自然也提供了这方面的语法.你可以使用 <code>extends</code>  关键词从一个类继承自另一个类. 在下面的这个例子中, <code>Parrot</code> 类就继承自 <code>Animal</code> 类, 包括了所有的实例方法, 例如 <code>alive()</code> 方法。</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  constructor: (@name) -&gt;

  alive: -&gt;
    false

class Parrot extends Animal
  constructor: -&gt;
    super("Parrot")

  dead: -&gt;
    not @alive()
</code></pre>

<p>从上一个例子中你可以看到，我们还使用了 <code>super()</code> 关键字. 如此做, this就指向了当前类“父类”的原形, 并且使用当前的作用域来执行. 在对应的js中, 就会生成 <code>Parrot.__super__.constructor.call(this, "Parrot");</code> 这样的一段申明. 实际运用中, 这样就好比是在 Ruby 或者 Python中使用 <code>super</code>, 执行被继承的函数.</p>

<p>通常来说当实例被创建的时候CoffeeScript会执行父类的 <code>constructor</code> 构造函数，除非你自己修改了构造函数.</p>

<p>CoffeeScript使用原形继承来继承一个类的所有实例方法.这保证了所有的类都是动态的; 即便是一个子类被创建后，在父类添加了实例方法，继承于它的子类依然能够使用这个方法.</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  constructor: (@name) -&gt;

class Parrot extends Animal

Animal::rip = true

parrot = new Parrot("Macaw")
alert("This parrot is no more") if parrot.rip
</code></pre>

<p>值得指出的是静态的属性都被拷贝到子类中, 而不是像实例属性那样通过原形来继承. 这主要源于Javascript原型架构的原因.</p>

<h2>混合(Mixins)</h2>

<p><a href="http://en.wikipedia.org/wiki/Mixin">混合(Mixins)</a> 并非CoffeeScript原生支持的特性, 但基于他们的好处，你可以自己写一个. 举例来说，混合包含两个函数, <code>extend()</code> 和 <code>include()</code> 分别可以向一个类中添加类属性和实例属性.</p>

<p><span class="csscript"></span></p>

<pre><code>extend = (obj, mixin) -&gt;
  obj[name] = method for name, method of mixin        
  obj

include = (klass, mixin) -&gt;
  extend klass.prototype, mixin

# Usage
include Parrot,
  isDeceased: true

(new Parrot).isDeceased
</code></pre>

<p>当继承的方式并不适用，但又需要在模块之间共享一些常用的逻辑的时候，混合就是很好的方式。混合的优势在于, 相比于继承的来源只有一个父类，你可以对自己的类加入很多的不同的特性或属性。</p>

<h2>扩展类</h2>

<p>混合(Mixin)非常的简洁优雅，但是他们的写法并没有面向对象. 我们就把Mixin整合进CoffeeScript的类之中. 我们先定义一个叫 <code>Module</code> 的类，通过这个类我们可以继承Mixin的特性. <code>Module</code> 拥有两个静态的方法, <code>@extend()</code> 和 <code>@include()</code>, 通过这两个方法，我们可以分别扩展一个类的静态和实例属性.</p>

<p><span class="csscript"></span></p>

<pre><code>moduleKeywords = ['extended', 'included']

class Module
  @extend: (obj) -&gt;
    for key, value of obj when key not in moduleKeywords
      @[key] = value

    obj.extended?.apply(@)
    this

  @include: (obj) -&gt;
    for key, value of obj when key not in moduleKeywords
      # Assign properties to the prototype
      @::[key] = value

    obj.included?.apply(@)
    this
</code></pre>

<p>The little dance around the moduleKeywords variable is to ensure we have callback support when mixins extend a class. 让我们看看 <code>Module</code> 类如何实际的使用:</p>

<p><span class="csscript"></span></p>

<pre><code>classProperties = 
  find: (id) -&gt;
  create: (attrs) -&gt;

instanceProperties =
  save: -&gt; 

class User extends Module
  @extend classProperties
  @include instanceProperties

# Usage:
user = User.find(1)

user = new User
user.save()
</code></pre>

<p>你可以看到, 我们添加了静态方法 <code>find()</code> 和 <code>create()</code> 到 <code>User</code> 这个类, 另外添加了实例方法 <code>save()</code>. 因为我们有模块扩展的回调, 我们可以通过接受静态和动态的属性来简化这一过程:</p>

<p><span class="csscript"></span></p>

<pre><code>ORM = 
  find: (id) -&gt;
  create: (attrs) -&gt;
  extended: -&gt;
    @include
      save: -&gt; 

class User extends Module
  @extend ORM
</code></pre>

<p>非常简单和高效吧！</p>

  </div>
</div>
</body>
</html><!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>The Little Book on CoffeeScript - Idioms</title>
<link rel="stylesheet" href="site/site.css" type="text/css" charset="utf-8">
<link rel="stylesheet" href="site/highlight.css" type="text/css" charset="utf-8">
<script src="site/jquery.js" type="text/javascript" charset="utf-8"></script>      
<script src="site/highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="site/coffee-script.js" type="text/javascript" charset="utf-8"></script>
<script src="site/preview.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
  hljs.initHighlightingOnLoad();
</script>
</head>
<body>
<div id="container">
  <header>
    <h1><a href="index.html">The Little Book on CoffeeScript</a></h1>
  </header>
  
  <div id="content">
    <div class="back"><a href="index.html">&laquo; 返回章节列表</a></div>


<h1>CoffeeScript常用编程模式</h1>

<p>每一种语言都有自己的惯用语法和编程的模式, CoffeeScript也不例外. 这一章就会涉及这些内容, 并且会对比JavaScript和CoffeeScript之间的区别，以便你能对CoffeeScript有更好的理解.</p>

<h2>遍历</h2>

<p>在JavaScript中遍历一个数组的每一项, 我们可以使用新增加的 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/foreach"><code>forEach()</code></a> 函数, 或者是用一个 C 风格的 <code>for</code> 循环. 如果你计划使用一些最新的JavaScript特性，我建议你在页面中引入 <a href="https://github.com/kriskowal/es5-shim">shim</a> 来支持旧的浏览器.</p>

<pre><code>for (var i=0; i &lt; array.length; i++)
  myFunction(array[i]);

array.forEach(function(item, i){
  myFunction(item)
});
</code></pre>

<p>尽管 <code>forEach()</code> 在语法上面更加的简介和可读, 但是它也受限于它的通过回调来执行的缺陷, 相比 <code>for</code> 循环就要慢许多. 让我们来看看在CoffeeScript里面是怎么样的.</p>

<p><span class="csscript"></span></p>

<pre><code>myFunction(item) for item in array
</code></pre>

<p>这样的语法更加可读，并且更加简洁， 我想你也会这么认为，并且所有的这一切都是在后台被编译为 <code>for</code> 循环. 换句话说 CoffeeScript 的语法提供了 <code>forEach()</code> 般的表现力, 并且解决了速度和低浏览器模拟的问题.</p>

<h2>图</h2>

<p>和 <code>forEach()</code> 类似, ES5 同样提供了一个原生的<a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/map"><code>map()</code></a>函数来代替 <code>for</code> 循环 . 不幸的是它的情况和 <code>forEach()</code> 类似, 因为调用方式的问题，它的速度也打了折扣.</p>

<pre><code>var result = []
for (var i=0; i &lt; array.length; i++)
  result.push(array[i].name)

var result = array.map(function(item, i){
  return item.name;
});
</code></pre>

<p>As we covered in the syntax chapter, CoffeeScript's comprehensions can be used to get the same behavior as <code>map()</code>. Notice we're surrounding the comprehension with parens, which is <strong>absolutely critical</strong> in ensuring the comprehension returns what you'd expect, the mapped array.</p>

<p>我们之前的语法部分介绍了, CoffeeScript的语句同样可以构造出类似 <code>map()</code> 的行为. 要注意的是我们在语句外面包了一层括号, 这非常<strong>关键</strong>,它确保语句返回的是我们想要的键值化数组.</p>

<p><span class="csscript"></span></p>

<pre><code>result = (item.name for item in array)
</code></pre>

<h2>筛选</h2>

<p>ES5 有一个功能函数 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/filter"><code>filter()</code></a> 用来筛选数组:</p>

<pre><code>var result = []
for (var i=0; i &lt; array.length; i++)
  if (array[i].name == "test")
    result.push(array[i])

result = array.filter(function(item, i){
  return item.name == "test"
});
</code></pre>

<p>CoffeeScript的基础语法则提供了 <code>when</code> 通过比较来进行数组条目的筛选. 这同样会生成一个 <code>for</code> 循环. 整个执行的过程会在一个匿名函数中进行，以避免作用域泄漏以及变量冲突.</p>

<p><span class="csscript"></span></p>

<pre><code>result = (item for item in array when item.name is "test")
</code></pre>

<p>别忘了加上括号, 否则 <code>result</code> 的值会是最后一个被筛选出来的条目.
CoffeeScript的语法非常的灵活, 下面的这个例子很好的展示了CoffeeScript强大的筛选功能.
<span class="csscript"></span></p>

<pre><code>passed = []
failed = []
(if score &gt; 60 then passed else failed).push score for score in [49, 58, 76, 82, 88, 90]

# Or
passed = (score for score in scores when score &gt; 60)
</code></pre>

<p>如果这样理解过于麻烦, 你可以把他们分成多行.</p>

<p><span class="csscript"></span></p>

<pre><code>passed = []
failed = []
for score in [49, 58, 76, 82, 88, 90]
  (if score &gt; 60 then passed else failed).push score
</code></pre>

<h2>包含</h2>

<p>我们常常会使用<code>indexOf()</code>方法来判断一个值是不是属于一个数组, 但由于IE还没有支持, 我们还是需要做一些兼容性的处理.</p>

<pre><code>var included = (array.indexOf("test") != -1)
</code></pre>

<p>许多Python开发者可能已经发现, 在CoffeeScript中使用了 <code>in</code> 来完美替代这个处理过程.</p>

<p><span class="csscript"></span></p>

<pre><code>included = "test" in array
</code></pre>

<p>在实际实现中, CoffeeScript使用了 <code>Array.prototype.indexOf()</code> 来检测一个值是否存在于一个数组中, 如果不支持这个, 就做降级处理.不幸的是, 这样做意味着<code>in</code>的语法不能对字符串无效.所以对于字串我们还得用回<code>indexOf()</code>, 并同时判断结果是否为-1:</p>

<p><span class="csscript"></span></p>

<pre><code>included = "a long test string".indexOf("test") isnt -1
</code></pre>

<p>或者我们改进一下, 使用位运算符这样就避免了和 <code>-1</code> 做对比.</p>

<p><span class="csscript"></span></p>

<pre><code>string   = "a long test string"
included = !!~ string.indexOf "test"
</code></pre>

<h2>属性遍历</h2>

<p>要在JavaScript中遍历一堆属性的话, 你需要使用<code>in</code>操作符, 举个例子:</p>

<pre><code>var object = {one: 1, two: 2}
for(var key in object) alert(key + " = " + object[key])
</code></pre>

<p>然而,正如你之前看到的,CoffeeScript已经把 <code>in</code> 关键字运用在了数组中. 这样一来,我们在CoffeeScript中使用 <code>of</code> 这个关键字来代替</p>

<p><span class="csscript"></span></p>

<pre><code>object = {one: 1, two: 2}
alert("#{key} = #{value}") for key, value of object
</code></pre>

<p>As you can see, you can specify variables for both the property name, and its value; rather convenient.
你可以看到,你可以同时获取属性名和属性值,相当的方便.</p>

<h2>最大值/最小值</h2>

<p>这个技术或许在CoffeeScript中并不算特别, 但是我想说说它的特别之处. <code>Math.max</code> 和 <code>Math.min</code> 可以接受多个参数,你可以使用 <code>...</code> 来传递一个数组给它们, 从而得到这个数组中的最大值和最小值.</p>

<p><span class="csscript"></span></p>

<pre><code>Math.max [14, 35, -7, 46, 98]... # 98
Math.min [14, 35, -7, 46, 98]... # -7
</code></pre>

<p>由于浏览器对函数参数的数量的限制问题,这个技巧在传递一个很大的数组的时候是没有什么意义的.</p>

<h2>多个参数</h2>

<p>在<code>Math.max</code>的例子中, 我们使用了 <code>...</code> 来构建一个数组并把它作为多个参数传递给 <code>max</code>.
实际实现中, CoffeeScript通过<code>apply()</code>调用的方式来进行函数的调用, 以保证数组作为一个参数传递给<code>max</code>, 我们可以换种方式来运用这一特性, 譬如说,proxying function calls:</p>

<p><span class="csscript"></span></p>

<pre><code>Log =
  log: -&gt;
    console?.log(arguments...)
</code></pre>

<p>或者你可一在参数被传入之前做一下修改.</p>

<p><span class="csscript"></span></p>

<pre><code>Log =
  logPrefix: "(App)"

  log: (args...) -&gt;
    args.unshift(@logPrefix) if @logPrefix
    console?.log(args...)
</code></pre>

<p>虽然你会感觉有些担心，但是CoffeeScript是会自动设置函数的执行上下文为函数触发时所属的对象.上面的例子中,上下文应该是 <code>console</code>. 如果你要设定特定的上下文,那么你就要手动的使用<code>apply()</code>的调用方式.</p>

<h2>与/非</h2>

<p>CoffeeScript 风格指南推荐用 <code>or</code> 代替 <code>||</code>, 用 <code>and</code> 代替 <code>&amp;&amp;</code>. 我说说为什么, 因为前者可读性更佳. 除此之外, 这两种方式的结果是一致的.</p>

<p>这种更接近英语的风格还有,如使用<code>is</code> 优于 <code>==</code> , <code>isnt</code> 优于 <code>!=</code>.</p>

<p><span class="csscript"></span></p>

<pre><code>string = "migrating coconuts"
string == string # true
string is string # true
</code></pre>

<p>CoffeeScript还添加了一个很棒的'或等于'的判断符,Ruby的程序员可能能很快认出来这和<code>||=</code>很相近.</p>

<p><span class="csscript"></span></p>

<pre><code>hash or= {}
</code></pre>

<p>如果hash等于<code>false</code>, 那么它就会被赋一个空对象的值. 需要注意的是, 这个表达式也会把<code>0</code>,<code>""</code>,<code>null</code>认成非值.如果你并不想这样,那就使用CoffeeScript的“存在”操作符, 它可以保证只在hash为<code>undefined</code>或是<code>null</code>的时候才被赋值:</p>

<p><span class="csscript"></span></p>

<pre><code>hash ?= {}
</code></pre>

<h2>析构赋值</h2>

<p>析构赋值可以被用来获取数组或者对象的深度属性.</p>

<p><span class="csscript"></span></p>

<pre><code>someObject = { a: 'value for a', b: 'value for b' }
{ a, b } = someObject
console.log "a is '#{a}', b is '#{b}'"
</code></pre>

<p>这在Node应用中引用模块的时候非常的有用:</p>

<p><span class="csscript"></span></p>

<pre><code>{join, resolve} = require('path')

join('/Users', 'Alex')
</code></pre>

<h2>外部库</h2>

<p>使用外部库和调用CoffeeScript的库的函数的方式基本一样, 因为最终所有的东西都会编译为JavaScript. 由于Jquery本身API设计包含了很多的回调, 在CoffeeScript中使用<a href="http://jquery.com">jQuery</a>会显得很顺其自然。</p>

<p><span class="csscript"></span></p>

<pre><code># Use local alias
$ = jQuery

$ -&gt;
  # DOMContentLoaded
  $(".el").click -&gt;
    alert("Clicked!")
</code></pre>

<p>由于所有的CoffeeScript产物都会被一个匿名函数所包裹, 我们可以设定一个本地变量 <code>$</code> 指向 <code>jQuery</code>.这可以保证即便jQuery冲突模式没有被开启,并且<code>$</code>被别的框架重写,我们的脚本依旧能工作正常.</p>

<h2>私有变量</h2>

<p><code>do</code> 关键字可以让我们在CoffeeScript中立即执行函数, 这是一种很好的封装作用域保护变量的方式.下面的例子中, 我们在一个使用<code>do</code>立即执行的匿名函数中定义了一个<code>classToType</code>变量.这个匿名函数返回了另一个匿名函数, 它会返回<code>type</code>的最终值.由于<code>classToType</code>被定义的上下文没有任何引用,外部作用域就无法访问它.</p>

<p><span class="csscript"></span></p>

<pre><code># Execute function immediately
type = do -&gt;
  classToType = {}
  for name in "Boolean Number String Function Array Date RegExp Undefined Null".split(" ")
    classToType["[object " + name + "]"] = name.toLowerCase()

  # Return a function
  (obj) -&gt;
    strType = Object::toString.call(obj)
    classToType[strType] or "object"
</code></pre>

<p>换句话说, <code>classToType</code> 的作用域是完全私有的, 并且不再会被匿名函数外部所引用.这种方式可以很好的封装作用域和隐藏变量.</p>

  </div>
</div>
</body>
</html><!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>The Little Book on CoffeeScript - Compiling</title>
<link rel="stylesheet" href="site/site.css" type="text/css" charset="utf-8">
<link rel="stylesheet" href="site/highlight.css" type="text/css" charset="utf-8">
<script src="site/jquery.js" type="text/javascript" charset="utf-8"></script>      
<script src="site/highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="site/coffee-script.js" type="text/javascript" charset="utf-8"></script>
<script src="site/preview.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
  hljs.initHighlightingOnLoad();
</script>
</head>
<body>
<div id="container">
  <header>
    <h1><a href="index.html">The Little Book on CoffeeScript</a></h1>
  </header>
  
  <div id="content">
    <div class="back"><a href="index.html">&laquo; 返回章节列表</a></div>


<h1>自动编译CoffeeScript</h1>

<p>CoffeeScript的一个问题在它在你和JavaScript之间又放置入了一层，并且你需要在CoffeeScript文件变化时重新手动编译. 幸运的是,CoffeeScript的有可选的编译方式, 使得你可以在修改和编译之间顺利的进行开发.</p>

<p>我们在第一章已经说过, 我们可以使用<code>coffee</code>命令进行CoffeeScript文件的编译:</p>

<pre><code>coffee --compile --output lib src
</code></pre>

<p>事实上, 在上面的例子中, 所有在<code>src</code>文件夹中的<code>.coffee</code>文件都会被编译成JavaScript并被存放到<code>lib</code>目录下面.不过一直的这样运行有一些没效率,那我们就来看看自动化编译吧.</p>

<h2>Cake</h2>

<p><a href="http://jashkenas.github.com/coffee-script/#cake">Cake</a>是一个通过<a href="http://www.gnu.org/software/make/">Make</a>和<a href="http://rake.rubyforge.org/">Rake</a>实现的非常简单的构建系统. 它是捆绑在<code>coffeee-script</code>包上面的一个库，我们可以通过<code>cake</code>命令来使用它.</p>

<p>你可以创建 <code>cakefile</code>来定义构建的任务.通过<code>cake [task] [option]</code>的方式,Cake可以在会在当前目录自动寻找配置,并执行构建任务. 要列出所有的任务和选项, 只需输入<code>cake</code>即可.</p>

<p>我们可以通过<code>task()</code>函数来定义任务, 它接受一个名称参数,一个可选描述和一个回调函数.举一个例子, 我们创建一个<code>Cakefile</code>和两个目录, <code>lib</code>和<code>src</code>. 并把下面的这些添加到<code>Cakefile</code>中:</p>

<p><span class="csscript"></span></p>

<pre><code>fs = require 'fs'

{print} = require 'sys'
{spawn} = require 'child_process'

build = (callback) -&gt;
  coffee = spawn 'coffee', ['-c', '-o', 'lib', 'src']
  coffee.stderr.on 'data', (data) -&gt;
    process.stderr.write data.toString()
  coffee.stdout.on 'data', (data) -&gt;
    print data.toString()
  coffee.on 'exit', (code) -&gt;
    callback?() if code is 0

task 'build', 'Build lib/ from src/', -&gt;
  build()
</code></pre>

<p>在上面的例子中,我们定义了一个任务叫<code>build</code>,只要通过<code>cake build</code>的命令就可以执行了.这个例子的运行效果和之前的例子一样,它会把所有<code>src</code>中的CoffeeScript文件都编译成<code>lib</code>目录中的JavaScript文件.你可以在HTML文件中引用<code>lib</code>目录下面的JavaScript文件.</p>

<p><span class="csscript"></span></p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=utf-8&gt;
&lt;script src="lib/app.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;      
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>当我们的CoffeeScript代码变化的时候,我们还是要手动调用<code>cake build</code>命令,这和理想的情况还有差距.幸运的是, <code>coffee</code> 命令支持一个 <code>--watch</code>选项, 它会监听目录的变化并会实时的做重编译.让我们再定义另一个任务:</p>

<p><span class="csscript"></span></p>

<pre><code> task 'watch', 'Watch src/ for changes', -&gt;
    coffee = spawn 'coffee', ['-w', '-c', '-o', 'lib', 'src']
    coffee.stderr.on 'data', (data) -&gt;
      process.stderr.write data.toString()
    coffee.stdout.on 'data', (data) -&gt;
      print data.toString()
</code></pre>

<p>如果一个任务依赖于另一个任务, 你可以使用<code>invoke(name)</code>的方式来运行另一个任务. 让我们在我们的<code>Cakefile</code>中添加一条任务,它可以打开<code>index.html</code>并开始监听他引用的源文件的变化.</p>

<p><span class="csscript"></span></p>

<pre><code>task 'open', 'Open index.html', -&gt;
  # First open, then watch
  spawn 'open', 'index.html'
  invoke 'watch'
</code></pre>

<p>你也可以使用<code>option()</code>函数来定义任务的选项,一个选项包含一个短名称, 一个长名称和描述.</p>

<p><span class="csscript"></span></p>

<pre><code>option '-o', '--output [DIR]', 'output dir'

task 'build', 'Build lib/ from src/', -&gt;
  # Now we have access to a `options` object
  coffee = spawn 'coffee', ['-c', '-o', options.output or 'lib', 'src']
  coffee.stderr.on 'data', (data) -&gt;
    process.stderr.write data.toString()
  coffee.stdout.on 'data', (data) -&gt;
    print data.toString()
</code></pre>

<p>你可以发现, 任务的上下文获取了一个包含用户数据的<code>options</code>对象.如果你直接使用<code>cake</code>命令而没有加上其他的参数, 所有的任务和选项都会被列出了.</p>

<p>Cake的伟大之处在于它可以编写各种自动化任务,例如自动编译CoffeeScript而不经过bash命令或者Makefile. <a href="http://jashkenas.github.com/coffee-script/documentation/docs/cake.html">Cake的源文件</a>也很值得一读, 它本身就是包含CoffeeScript的表现力, 并且它的注释也写得很漂亮.</p>

<h2>服务器端的编译支持</h2>

<p>使用Cake的方式来编译对于静态站点来说很合适,但是对于动态站点,我们可能就需要把CoffeeScript的编译过程整合在请求\响应的过程中.目前在一些框架中已经出现了一些整合方案,例如<a href="http://rubyonrails.org/">Rails</a> 和 <a href="https://www.djangoproject.com/">Django</a>.</p>

<p>在Rails 3.1中, 可以通过<a href="https://github.com/sstephenson/sprockets">Sprockets &amp; the asset pipeline</a>来支持CoffeeScript.在<code>app/assets/javascripts</code>目录下面存放你的CoffeeScript文件, Rails可以很智能的在文件请求前预处理. JavaScript文件和CoffeeScript文件都通过特殊的注释指令被串联和打包在一起, 这意味着你可以在一次请求中获取所有的的JavaScript文件. 而对于生产代码，Rails会把编译后的文件输出在硬盘中, 保证它可以被缓存并被快速的访问.</p>

<p>如果你的应用不需要其他的 Rails 特性以及相关的功能, 那么对于Ruby来说,像内置了Rack服务的37signal的<a href="http://pow.cx/">Pow</a>和Joshua Peek的<a href="http://josh.github.com/nack/">Nack</a>都是很好的选择.</p>

<p>Django通过特殊的模块标签也对CoffeeScript提供了<a href="http://pypi.python.org/pypi/django-coffeescript/">支持</a>,它同时支持行内脚本和外部脚本.</p>

<p>不管是Ruby还是Python,都会输出到 Node 中,然后通过CoffeeScript库来进行编译,因此在开发时要确保这些都已经安装了. 如果你的网站直接是用Node搭建的, 整合Coffeescript就更简单了,你也可以在前后端同时使用CoffeeScript.我们会在下一章详细介绍这个, 并使用<a href="https://github.com/sstephenson/stitch">Stitch</a>来提供客户端的CoffeeScript服务.</p>

  </div>
</div>
</body>
</html><!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>The Little Book on CoffeeScript - Applications</title>
<link rel="stylesheet" href="site/site.css" type="text/css" charset="utf-8">
<link rel="stylesheet" href="site/highlight.css" type="text/css" charset="utf-8">
<script src="site/jquery.js" type="text/javascript" charset="utf-8"></script>      
<script src="site/highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="site/coffee-script.js" type="text/javascript" charset="utf-8"></script>
<script src="site/preview.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
  hljs.initHighlightingOnLoad();
</script>
</head>
<body>
<div id="container">
  <header>
    <h1><a href="index.html">The Little Book on CoffeeScript</a></h1>
  </header>
  
  <div id="content">
    <div class="back"><a href="index.html">&laquo; 返回章节列表</a></div>


<h1>创建CoffeeScript应用</h1>

<p>现在的你应该对语法已经有大致的了解了, 我们就来实际的构建和创建CoffeeScript应用. 希望对本章的阅读会对所有CoffeeScript开发者有帮助,不论是初学者还是高手,事实上,它与纯JavaScript开发者是息息相关的.
Now you've been given an overview of the syntax, lets explore actually structuring and creating CoffeeScript applications. This section aims to be useful to all CoffeeScript developers, novice or advanced. Indeed, it should be relevant to pure JavaScript developers too.</p>

<p>由于一些原因, 很多人在编写客户端JavaScript应用的时候, 还是会忘记一些惯例和常用模式, 从而导致了意大利面条式耦合的不易维护的JavaScript.在这里我不想重申一个应用的架构是多么重要; 如果你使用CoffeeScript或者JavaScript不仅仅是编写简单的表单验证, 你应当使用一些例如<a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a>的开发模式.</p>

<p>构建可维护的大型应用程序并不仅仅意味着构建大的应用. 换句话说, 你需要构建一系列的相互不耦合的组件. 尽可能的保证应用逻辑的通用, 并进行适当的抽象. 最后,把你的逻辑分到view,model，controller(MVC)三层当中. 本章讲不会涉及MVC, 如果你要了解这方面的知识, 我建议你阅读我的另一本书<a href="http://oreilly.com/catalog/9781449307530/">JavaScript Web Applications</a> 并使用<a href="http://documentcloud.github.com/backbone/">Backbone</a> or <a href="https://github.com/maccman/spine">Spine</a>这样的框架. 在这里的话, 我们则会介绍使用CommonJS模块来构建应用.</p>

<h2>架构 和 CommonJS</h2>

<p>那么到底什么是CommonJS模块呢?如果你在之前使用过<a href="http://nodejs.org/">NodeJS</a>, 你可能没有意识到你已经在使用CommonJS了.CommonJS规范最初是用在服务器端的JavaScript库上面, 主要解决的是加载,命名空间,作用域等问题. CommonJS旨在在所用的JavaScript实现里都使用通用的形式. CommonJS旨在使工作于<a href="http://www.mozilla.org/rhino/">Rhino</a>的库也可以在Node下面运行. 最终,这些想法都被带到了浏览器中,因而就有了我们现在知道的<a href="http://requirejs.org">RequireJS</a> 和 <a href="https://github.com/jbrantly/yabble">Yabble</a> 这样的库让我们在客户端使用模块.</p>

<p>老实说, 模块可以确保你的代码在一个本地命名空间下运行(代码封装), 你可以通过<code>require()</code>函数来加载别的模块,也可以使用<code>module.exports</code>来输出模块.接下来我们在深入一些.</p>

<h3>文件依赖载入</h3>

<p>你可以使用<code>require()</code>来加载别的模块和库. 只需传一个模块名, 如果此模块名的文件存在于加载的路径下, 那么将会返回一个代表此模块的对象,比如说:</p>

<pre><code>User = require("models/user")
</code></pre>

<p>对同步载入的支持一直是一个问题, 好在这个问题基本上被最新的CommonJS<a href="http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition">提案</a>和主流的loader库解决了. 如果你要摒弃我下面会提到的Stitch而采用别的方式,那你可能必须考虑一下别的处理同步载入的方式.
Synchronous require support is a contentious issue, but has mostly been resolved with the mainstream loader libraries and latest CommonJS <a href="http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition">proposals</a>. It may be something you'll have to look into if you decided to take a separate route than the one I'm advocating with Stitch below.</p>

<h3>属性的输出</h3>

<p>默认情况下, 模块不会输出任何的属性,因此它们对于<code>require()</code>的调用是完全不可见的.如果你希望你的模块有部分属性暴露给外部调用,你就要通过<code>module.exports</code>来设定.</p>

<pre><code># random_module.js
module.exports.myFineProperty = -&gt;
  # Some shizzle
</code></pre>

<p>这样,当这个模块被载入时,<code>myFineProperty</code>就会暴露出来.
Now, whenever this module is required then <code>myFineProperty</code> will be exposed:</p>

<pre><code>myFineProperty = require("random_module").myFineProperty
</code></pre>

<h2>使用Stitch</h2>

<p>把你的代码使用CommonJS的模块来组织固然好, 但是我们如何在客户端来做呢?我选择的是一个闻所未闻的<a href="https://github.com/sstephenson/stitch">Stitch</a> 库.Stitch是Sam Stephenson写的, 它的基于<a href="http://www.prototypejs.org">Prototype.js</a>并解决了模块的问题,这是我用它的最大动机.
与其他通过动态加载模块的库不同的是,Stitch 简单的把所有的JavaScript捆绑为同一个,并用CommonJS进行封装. 哦, 对了, 它还会编译你的CoffeeScript, JS模板, <a href="http://lesscss.org">LESS CSS</a> 和 <a href="http://sass-lang.com">Sass</a> 文件!</p>

<p>首先如果你没有安装<a href="http://nodejs.org/">Node.js</a> 和 <a href="http://npmjs.org/">npm</a>你要先进行安装. 它们会在本章的例子中一直被用到.</p>

<p>现在, 我们来规划一下整个应用架构. 如果你使用<a href="https://github.com/maccman/spine">Spine</a>, 你可以用<a href="http://github.com/maccman/spine.app">Spine.App</a>来自动化创建, 否则你就要手动来创建. 我通常会在<code>app</code>目录来存放所有的应用代码, 在<code>lib</code>中存放通用的库文件.其他的东西, 包括静态资源, 都放在<code>public</code>目录中.</p>

<pre><code>app
app/controllers
app/views
app/models
app/lib
lib
public
public/index.html
</code></pre>

<p>现在我们开启Stitch服务器. 我们来先来创建一个 <code>index.coffee</code> 文件,并加入如下的代码:</p>

<p><span class="csscript"></span></p>

<pre><code>require("coffee-script")
stitch  = require("stitch")
express = require("express")
argv    = process.argv.slice(2)

package = stitch.createPackage(
  # Specify the paths you want Stitch to automatically bundle up
  paths: [ __dirname + "/app" ]

  # Specify your base libraries
  dependencies: [
    # __dirname + '/lib/jquery.js'
  ]
)
app = express.createServer()

app.configure -&gt;
  app.set "views", __dirname + "/views"
  app.use app.router
  app.use express.static(__dirname + "/public")
  app.get "/application.js", package.createServer()

port = argv[0] or process.env.PORT or 9294
console.log "Starting server on port: #{port}"
app.listen port
</code></pre>

<p>我们的依赖有<code>coffee-script</code>, <code>stitch</code> and <code>express</code>. 我们需要创建一个<code>package.json</code>文件, 来罗列这些依赖,这样npm可以来载入这些依赖.我们的<code>./package.json</code>文件具体内容如下:</p>

<pre><code>{
  "name": "app",
  "version": "0.0.1",
  "dependencies": { 
    "coffee-script": "~1.1.2",
    "stitch": "~0.3.2",
    "express": "~2.5.0",
    "eco": "1.1.0-rc-1"
  }
}
</code></pre>

<p>让我们通过npm来安装那些依赖:</p>

<pre><code>npm install .
npm install -g coffee-script
</code></pre>

<p>好的,搞定了coffee-script之后,现在执行:</p>

<pre><code>coffee index.coffee
</code></pre>

<p>这样你的Stitch服务器就运行起来了.我们继续并在<code>app</code>目录下面放一个<code>app.coffee</code>脚本来进行一下测试. 我们用这个文件来做整个应用的引导文件.</p>

<p><span class="csscript"></span></p>

<pre><code>module.exports = App =
  init: -&gt;
    # Bootstrap the app
</code></pre>

<p>现在创建我们的主页<code>index.html</code>, 如果你是在创建一个单页面的应用程序,那么这将是用户访问唯一的页面. 这是一个静态资源, 因此我们把它放在<code>public</code>目录下面.</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=utf-8&gt;
  &lt;title&gt;Application&lt;/title&gt;
  &lt;!-- Require the main Stitch file --&gt;
  &lt;script src="/application.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;
  &lt;script type="text/javascript" charset="utf-8"&gt;
    document.addEventListener("DOMContentLoaded", function(){
      var App = require("app");
      App.init();
    }, false);
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>当页面载入之后, 我们的 <em>DOMContentLoaded</em> 事件回调中会加载<code>app.coffee</code>脚本(它已经被自动编译) 并执行<code>init()</code>函数. 这就是所有的,我们已经有了CommonJS模块并运行起来,这也包括HTTP服务器和CoffeeScript编译器. 现在假设, 我们想引入一个模块, 只需要调用一下<code>require()</code>. 让我们来创建一个新的类 - <code>User</code>, 并在<code>app.coffee</code>里面来引用它:</p>

<p><span class="csscript"></span></p>

<pre><code># app/models/user.coffee
module.exports = class User
  constructor: (@name) -&gt;

# app/app.coffee
User = require("models/user")
</code></pre>

<h2>JavaScript模板</h2>

<p>如果你在客户端编写逻辑, 那么你很可能需要一套模板库.JavaScript的模板与服务器端的模板非常类似, 比如Ruby的ERB和Python的文本插值. 目前已经有很多的模板库了, 我建议你使用时做一番对比和调查.默认情况下,Stitch支持<a href="https://github.com/sstephenson/eco">Eco</a>模板.</p>

<p>JavaScript的模板与服务器端的模板非常类似. 你会在里面使用还有HTML的插值标签, 在渲染时, 这些标签都会被赋值和替换. <a href="https://github.com/sstephenson/eco">Eco</a> 模板的给力之处在于他们是由CoffeeScript写的.</p>

<p>这里有一个例子:</p>

<pre><code>&lt;% if @projects.length: %&gt;
  &lt;% for project in @projects: %&gt;
    &lt;a href="&lt;%= project.url %&gt;"&gt;&lt;%= project.name %&gt;&lt;/a&gt;
    &lt;p&gt;&lt;%= project.description %&gt;&lt;/p&gt;
  &lt;% end %&gt;
&lt;% else: %&gt;
  No projects
&lt;% end %&gt;
</code></pre>

<p>你可以看到, 它的语法非常简单. 只要用<code>&lt;%</code>标签来包裹表达式, 使用<code>&lt;%=</code>标签来打印表达式结果.模板标签的部分使用规则如下:</p>

<ul>
<li><p><code>&lt;% expression %&gt;</code><br/>
执行一个CoffeeScript表达式而不输出任何内容.</p></li>
<li><p><code>&lt;%= expression %&gt;</code><br/>
执行一个CoffeeScript表达式, 并且对返回值进行转义和输出.</p></li>
<li><p><code>&lt;%- expression %&gt;</code><br/>
执行一个CoffeeScript表达式, 对返回值不转义即输出.</p></li>
</ul>


<p>你可以在模板的标签中加入任意的CoffeeScript表达式, 但是有一个要注意的. CoffeeScript对于空格是敏感的, 但是Eco模板系统不会. 因此使用Eco模版标签包裹代码块时,要在起始标签中最后以冒号结尾, 在结束标签中显式的使用<code>&lt;% end %&gt;</code>,例如:</p>

<pre><code>&lt;% if @project.isOnHold(): %&gt;
  On Hold
&lt;% end %&gt;
</code></pre>

<p>其实也你用把<code>if</code> 和 <code>end</code>标签分行写:</p>

<pre><code>&lt;% if @project.isOnHold(): %&gt; On Hold &lt;% end %&gt;
</code></pre>

<p>甚至你可以使用单行的方式输出这条<code>if</code>语句:</p>

<pre><code>&lt;%= "On Hold" if @project.isOnHold() %&gt;
</code></pre>

<p>现在我们基本掌握了语法, 我们就在<code>views/users/show.eco</code>文件中定义一个Eco模板:</p>

<pre><code>&lt;label&gt;Name: &lt;%= @name %&gt;&lt;/label&gt;
</code></pre>

<p>Stitch会自动编译我们的模板,并在<code>application.js</code>中包含它. 然后, 在我们的应用controller中,我们就可以载入这个模板, 这就好比一个模块, 我们传入了参数并执行它.</p>

<p><span class="csscript"></span></p>

<pre><code>require("views/users/show")(new User("Brian"))
</code></pre>

<p>我们的<code>app.coffee</code>文件现在应该差不多是这样, 渲染模板并在文档加载时,把模板输出到页面中:</p>

<p><span class="csscript"></span></p>

<pre><code>User = require("models/user")

App =
  init: -&gt;
    template = require("views/users/show")
    view     = template(new User("Brian"))

    # Obviously this could be spruced up by jQuery
    element = document.createElement("div")
    element.innerHTML = view
    document.body.appendChild(element)

module.exports = App
</code></pre>

<p>打开<a href="http://localhost:9294/">应用</a>看看！希望这个教程能够帮你了解如何使用CoffeeScript来构建客户端应用.至于后面的使用, 我建议你检出<a href="http://documentcloud.github.com/backbone/">Backbone</a> 或者 <a href="http://spinejs.com">Spine</a>这样的客户端框架, 他们会给你提供基础的MVC架构,让你的工作更充满乐趣.</p>

<h2>附 - 30秒学会使用Heroku开发</h2>

<p><a href="http://heroku.com/">Heroku</a> 是一个非常棒的在线程序托管服务, 它可以提供所有的服务器管理和规模化应用托管服务, 让你能够部署各种各样的JavaScript 应用.在开始这个教程前,你要先注册一个Heroku的账户, 好消息是, Heroku的基础服务是完全免费的. 作为一个传统的Ruby的托管服务, Heroku 最近也提供了Node的支持.
<a href="http://heroku.com/">Heroku</a> is an incredibly awesome web host that manages all the servers and scaling for you, letting you get on with the exciting stuff (building awesome JavaScript applications). You'll need an account with Heroku for this tutorial to work, but the great news is that their basic plan is completely free. While traditionally a Ruby host, Heroku have recently released their Cedar stack, which includes Node support.</p>

<p>首先我们要创建一个<code>Procfile</code>, 用它来把我们应用的信息告知Heroku.</p>

<pre><code>echo "web: coffee index.coffee" &gt; Procfile
</code></pre>

<p>然后如果你应用还没有本地git仓库的话, 我们来创建一个.</p>

<pre><code>git init
git add .
git commit -m "First commit"    
</code></pre>

<p>现在就可以通过<code>heroku</code>gem包(如果没有的话你需要提前安装)来托管应用了.</p>

<pre><code>heroku create myAppName --stack cedar
git push heroku master
heroku open
</code></pre>

<p>好了, 准确的说这就是你要做的所有事情, 托管Node应用没有比这更简单的了.</p>

<h2>其他库</h2>

<p><a href="https://github.com/sstephenson/stitch">Stitch</a> 和 <a href="https://github.com/sstephenson/eco">Eco</a>并非你构建CoffeeScript和Node应用的唯一选择.</p>

<p>举个例子, 模板你还可以使用<a href="http://mustache.github.com">Mustache</a>, <a href="http://jade-lang.com">Jade</a>,或者使用纯CoffeeScript的方式的<a href="http://coffeekup.org">CoffeeKup</a>编写你的HTML</p>

<p>而对于应用服务, <a href="http://github.com/maccman/hem">Hem</a>是一个很好的选择, 它支持CommonJS和NPM模块,并无缝整合了CoffeeScript的MVC框架<a href="http://spinejs.com">Spine</a>. <a href="https://github.com/substack/node-browserify">node-browsify</a>是另一个类似的项目.或者你想整合<a href="http://expressjs.com/">express</a>, 你可以选择Trevor Burnham的 <a href="https://github.com/TrevorBurnham/connect-assets">connect-assets</a></p>

<p>在CoffeeScript的<a href="https://github.com/jashkenas/coffee-script/wiki/Web-framework-plugins">项目 wiki</a>上面, 你可以找到一个CoffeeScriptweb框架插件的完整列表.</p>

  </div>
</div>
</body>
</html><!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>The Little Book on CoffeeScript - The Bad Parts</title>
<link rel="stylesheet" href="site/site.css" type="text/css" charset="utf-8">
<link rel="stylesheet" href="site/highlight.css" type="text/css" charset="utf-8">
<script src="site/jquery.js" type="text/javascript" charset="utf-8"></script>      
<script src="site/highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="site/coffee-script.js" type="text/javascript" charset="utf-8"></script>
<script src="site/preview.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
  hljs.initHighlightingOnLoad();
</script>
</head>
<body>
<div id="container">
  <header>
    <h1><a href="index.html">The Little Book on CoffeeScript</a></h1>
  </header>
  
  <div id="content">
    <div class="back"><a href="index.html">&laquo; Back to all chapters</a></div>


<h1>The Bad Parts</h1>

<p>JavaScript is a tricky beast, and knowing the parts that you should avoid is just as important as knowing about the parts you should use. As Sun Tzu says, "know your enemy", and that's exactly what we're going to do in the chapter, exploring the dark side of JavaScript and revealing all the lurking monsters ready to pounce on the unsuspecting developer.</p>

<p>As I mentioned in the introduction, CoffeeScript's awesomeness lies not only in it's syntax, but in it's ability to fix some of JavaScript's warts. However, due to the fact that CoffeeScript statements have a direct translation into JavaScript, and don't run in a virtual machine or interpreter, the language is not a silver bullet to all of JavaScript's bugbears and there's still some issues you need to be aware about.</p>

<p>First, let's talk about what things the language does solve.</p>

<h2>A JavaScript Subset</h2>

<p>CoffeeScript's syntax only covers a subset of JavaScript's, the famous <em>Good Parts</em>, so already there's less to fix. Let's take the <code>with</code> statement for example. This statement has for a long time been "considered harmful", and should be avoided. <code>with</code> was intended to provide a shorthand for writing recurring property lookups on objects. For example, instead of writing:</p>

<pre><code>dataObj.users.alex.email = "info@eribium.org";
</code></pre>

<p>You could write:</p>

<pre><code>with(dataObj.users.alex) {
  email = "info@eribium.org";
}
</code></pre>

<p>Setting aside the fact that we shouldn't have such a deep object in the first place, the syntax is quite clean. Except for one thing. It's damn confusing to the JavaScript interpreter - it doesn't know exactly what you're going to do in the <code>with</code> context, and forces the specified object to be searched first for all name lookups.</p>

<p>This really hurts performance and means the interpreter has to turn off all sorts of JIT optimizations. Additionally <code>with</code> statements can't be minified using tools like <a href="https://github.com/mishoo/UglifyJS">uglify-js</a>. They're also deprecated and removed from future JavaScript versions. All things considered, it's much better just to avoid using them, and CoffeeScript takes this a step further by eliminating them from it's syntax. In other words, using <code>with</code> in CoffeeScript will throw a syntax error.</p>

<h2>Global variables</h2>

<p>By default, your JavaScript programs run in a global scope, and by default any variables created are in that global scope. If you want to create a variable in the local scope, JavaScript requires explicitly indicating that fact using the <code>var</code> keyword.</p>

<pre><code>usersCount = 1;        // Global
var groupsCount = 2;   // Global

(function(){              
  pagesCount = 3;      // Global
  var postsCount = 4;  // Local
})()
</code></pre>

<p>This is a bit of an odd decision since the vast majority of the time you'll be creating local variables not global, so why not make that the default? As it stands, developers have to remember to put <code>var</code> statements before any variables they're initializing, or face weird bugs when variables accidentally conflict and overwrite each other.</p>

<p>Luckily CoffeeScript comes to your rescue here by eliminating implicit global variable assignment entirely. In other words, the <code>var</code> keyword is reserved in CoffeeScript, and will trigger a syntax error if used. Local variables are created implicitly by default, and it's very difficult to create global variables without explicitly assigning them as properties on <code>window</code>.</p>

<p>Let's have a look at an example of CoffeeScript's variable assignment:</p>

<p><span class="csscript"></span></p>

<pre><code>outerScope = true
do -&gt;
  innerScope = true
</code></pre>

<p>Compiles down to:</p>

<pre><code>var outerScope;
outerScope = true;
(function() {
  var innerScope;
  return innerScope = true;
})();
</code></pre>

<p>Notice how CoffeeScript initializes variables (using <code>var</code>) automatically in the context their first used. Whilst it's impossible to shadow outer variables, you can still refer to and access them. You need to watch out for this, be careful that you're not reusing the name of an external variable accidentally if you're writing a deeply nested function or class. For example, here we're accidentally overwriting the <code>package</code> variable in a Class function:</p>

<p><span class="csscript"></span></p>

<pre><code>package = require('./package')

class Hem
  build: -&gt;
    # Overwrites outer variable!
    package = @hemPackage.compile()

  hemPackage: -&gt;
    package.create()
</code></pre>

<p>Global variables are needed from time to time, and to create those you need to set them as properties on <code>window</code>:</p>

<p><span class="csscript"></span></p>

<pre><code>  class window.Asset
    constructor: -&gt;
</code></pre>

<p>By ensuring global variables are explicit, rather than implicit, CoffeeScript removes one of the major sources of bugs in JavaScript programs.</p>

<h2>Semicolons</h2>

<p>JavaScript does not enforce the use of semicolons in source code, so it's possible to omit them. However, behind the scenes the JavaScript compiler still needs them, so the parser automatically inserts them whenever it encounters a parse error due to a missing semicolon. In other words, it'll try to evaluate a statement without semicolons and, if that fails, tries again using semicolons.</p>

<p>Unfortunately this is a tremendously bad idea, and can actually change the behavior of your code. Take the following example, seems valid JavaScript, right?</p>

<pre><code>function() {}
(window.options || {}).property
</code></pre>

<p>Wrong, well at least according to the parser; it raises a syntax error. In case of a leading parenthesis, the parser will not insert a semicolon. The code gets transformed onto one line:</p>

<pre><code>function() {}(window.options || {}).property
</code></pre>

<p>Now you can see the issue, and why the parser is complaining. When you're writing JavaScript, you should always include semicolons after statements. Fortunately CoffeeScript gets round all this hassle by not having semicolons in its syntax. Rather the semicolons are inserted automatically (at the right places) when the CoffeeScript is compiled down to JavaScript.</p>

<h2>Reserved words</h2>

<p>Certain keywords in JavaScript are reserved for future versions of JavaScript, such as <code>const</code>, <code>enum</code> and <code>class</code>. Using these as variable names in your JavaScript programs can unpredictable results; some browsers will cope with them just fine, and others will choke. CoffeeScript neatly sidesteps this issue, by detecting if you're using a reserved keyword, and escaping it if necessary.</p>

<p>For example, let's say you were to use the reserved keyword <code>class</code> as a property on an object, your CoffeeScript might look like this:</p>

<p><span class="csscript"></span></p>

<pre><code>myObj = {
  delete: "I am a keyword!"
}
myObj.class = -&gt;
</code></pre>

<p>The CoffeeScript parser notices you're using a reserved keyword, and quotes it for you:</p>

<pre><code>var myObj;
myObj = {
  "delete": "I am a keyword!"
};
myObj["class"] = function() {};
</code></pre>

<h2>Equality comparisons</h2>

<p>The weak equality comparison in JavaScript has some confusing behavior and is often the source of confusing bugs. The example below is taken from <a href="http://bonsaiden.github.com/JavaScript-Garden/#types.equality">JavaScript Garden's equality section</a> which delves into the issue in some depth.</p>

<p><span class="csscript"></span></p>

<pre><code>""           ==   "0"           // false
0            ==   ""            // true
0            ==   "0"           // true
false        ==   "false"       // false
false        ==   "0"           // true
false        ==   undefined     // false
false        ==   null          // false
null         ==   undefined     // true
" \t\r\n"    ==   0             // true
</code></pre>

<p>The reason behind this behavior is that the weak equality coerces types automatically. I'm sure you'll agree this is all pretty ambiguous, and can lead to unexpected results and bugs.</p>

<p>The solution is to instead use the strict equality operator, which consists of three equal signs: <code>===</code>. It works exactly like the normal equality operator, but without any type coercion. It's recommended to always use the strict equality operator, and explicitly convert types if needs be.</p>

<p>CoffeeScript solves this by simply replacing all weak comparisons with strict ones, in other words converting all <code>==</code> comparators into <code>===</code>. You can't do a a weak equality comparison in CoffeeScript, and you should explicitly convert types before comparing them if necessary.</p>

<p>This doesn't mean you can ignore type coercion in CoffeeScript completely though, especially when it comes to checking the 'truthfulness' of variables during flow control. Blank strings, <code>null</code>, <code>undefined</code> and the number <code>0</code> are all coerced to <code>false</code></p>

<p><span class="csscript"></span></p>

<pre><code>alert("Empty Array")  unless [].length
alert("Empty String") unless ""
alert("Number 0")     unless 0
</code></pre>

<p>If you want to explicitly check for <code>null</code> and <code>undefined</code>, then you can use CoffeeScript's existential operator:</p>

<p><span class="csscript"></span></p>

<pre><code>alert("This is not called") unless ""?
</code></pre>

<p>The <code>alert()</code> in the previous example won't be called, as the empty string isn't equal to <code>null</code>.</p>

<h2>Function definition</h2>

<p>Oddly enough in JavaScript, functions can be defined after they're used. For example, the following runs absolutely fine, even though <code>wem</code> is defined after it's called:</p>

<pre><code>wem();
function wem() {}
</code></pre>

<p>The is because of function scope. Functions get hoisted before the programs execution and as such are available everywhere in the scope they were defined in, even if called before the actual definition in the source. The trouble is, hoisting behavior differs between browser; for example:</p>

<pre><code>if (true) {
  function declaration() {
    return "first";
  }
} else {
  function declaration() {
    return "second";
  }
}
declaration();
</code></pre>

<p>In some browsers such as Firefox, <code>declaration()</code> will return <code>"first"</code>, and in other browsers like Chrome it'll return <code>"second"</code>, even though it looks like the <code>else</code> statement is never run.</p>

<p>If you want to know more about declarative functions, then you should read <a href="http://kangax.github.com/nfe/">Juriy Zaytsev's guide</a>, where he delves into the specifics. Suffice to say, they have fairly ambiguous behavior, and can lead to problems later down the road. All things considered, It's best to steer clear of them by using function expressions instead:</p>

<pre><code>var wem = function(){};
wem();
</code></pre>

<p>CoffeeScript's approach to this is to remove declarative functions entirely, using only function expressions.</p>

<h2>Number property lookups</h2>

<p>A flaw in JavaScript's parser means that the <em>dot notation</em> on numbers is interpreted as a floating point literal, rather than a property lookup. For example, the following JavaScript will cause a syntax error:</p>

<pre><code>5.toString();
</code></pre>

<p>JavaScript's parser is looking for another Number after the dot, and so raises an <code>Unexpected token</code> error when it encounters <code>toString()</code>. The solution to this is to either use parenthesis, or add an additional dot.</p>

<pre><code>(5).toString();
5..toString();
</code></pre>

<p>Fortunately CoffeeScript's parsers is clever enough to deal with this issue by using double dot notations automatically (as in the example above) whenever you access properties on Numbers.</p>

<h1>The un-fixed parts</h1>

<p>Whilst CoffeeScript goes some length to solving some of JavaScript's design flaws, it can only go so far. As I mentioned previously, CoffeeScript's strictly limited to static analysis by design, and doesn't do any runtime checking for performance reasons. CoffeeScript uses a straight source-to-source compiler, the idea being that every CoffeeScript statement results in a equivalent JavaScript statement. CoffeeScript doesn't provide an abstraction over any of JavaScript's keywords, such as <code>typeof</code>, and as such some design flaws in JavaScript's design also apply to CoffeeScript.</p>

<p>In the previous sections we covered some design flaws in JavaScript that CoffeeScript fixes. Now let's talk about some of JavaScript's flaws that CoffeeScript can't fix.</p>

<h2>Using eval</h2>

<p>Whilst CoffeeScript removes some of JavaScript's foibles, other features are a necessary evil, you just need to be aware of their shortcomings. A case in point, is the <code>eval()</code> function. Whilst undoubtedly it has its uses, you should know about its drawbacks, and avoid it if possible. The <code>eval()</code> function will execute a string of JavaScript code in the local scope, and functions like <code>setTimeout()</code> and <code>setInterval()</code> can also both take a string as their first argument to be evaluated.</p>

<p>However, like <code>with</code>, <code>eval()</code> throws the compiler off track, and is a major performance hog. As the compiler has no idea what's inside until runtime, it can't perform any optimizations like inlining. Another concern is with security. If you give it dirty input, <code>eval</code> can easily open up your code for injection attacks. 99% of the time when you're using <code>eval</code>, there are better &amp; safer alternatives (such as square brackets).</p>

<p><span class="csscript"></span></p>

<pre><code># Don't do this
model = eval(modelName)

# Use square brackets instead
model = window[modelName]
</code></pre>

<h2>Using typeof</h2>

<p>The <code>typeof</code> operator is probably the biggest design flaw of JavaScript, simply because it's basically completely broken. In fact, it really has only one use, checking to see if a value is <code>undefined</code>.</p>

<p><span class="csscript"></span></p>

<pre><code>typeof undefinedVar is "undefined"
</code></pre>

<p>For all other types of type checking, <code>typeof</code> fails rather miserably, returning inconsistent results depending on the browser and how instances were instantiated. This isn't something that CoffeeScript can help you either, since the language uses static analysis and has no runtime type checking. You're on your own here.</p>

<p>To illustrate the problem, here's a table taken from <a href="http://bonsaiden.github.com/JavaScript-Garden/">JavaScript Garden</a> which shows some of the major inconstancies in the keyword's type checking.</p>

<pre><code>Value               Class      Type
-------------------------------------
"foo"               String     string
new String("foo")   String     object
1.2                 Number     number
new Number(1.2)     Number     object
true                Boolean    boolean
new Boolean(true)   Boolean    object
new Date()          Date       object
new Error()         Error      object
[1,2,3]             Array      object
new Array(1, 2, 3)  Array      object
new Function("")    Function   function
/abc/g              RegExp     object
new RegExp("meow")  RegExp     object
{}                  Object     object
new Object()        Object     object
</code></pre>

<p>As you can see, depending on if you define a string with quotes or with the <code>String</code> class affects the result of <code>typeof</code>. Logically <code>typeof</code> should return <code>"string"</code> for both checks, but for the latter it returns <code>"object"</code>. Unfortunately the inconstancies only get worse from there.</p>

<p>So what can we use for type checking in JavaScript? Well, luckily <code>Object.prototype.toString()</code> comes to the rescue here. If we invoke that function in the context of a particular object, it'll return the correct type. All we need to do is massage the string it returns, so we end up with the sort of string <code>typeof</code> should be returning. Here's an example implementation ported from jQuery's <code>$.type</code>:</p>

<p><span class="csscript"></span></p>

<pre><code>type = do -&gt;
  classToType = {}
  for name in "Boolean Number String Function Array Date RegExp Undefined Null".split(" ")
    classToType["[object " + name + "]"] = name.toLowerCase()

  (obj) -&gt;
    strType = Object::toString.call(obj)
    classToType[strType] or "object"

# Returns the sort of types we'd expect:
type("")         # "string"
type(new String) # "string"
type([])         # "array"
type(/\d/)       # "regexp"
type(new Date)   # "date"
type(true)       # "boolean"
type(null)       # "null"
type({})         # "object"
</code></pre>

<p>If you're checking to see if an variable has been defined, you'll still need to use <code>typeof</code> otherwise you'll get a <code>ReferenceError</code>.</p>

<p><span class="csscript"></span></p>

<pre><code>if typeof aVar isnt "undefined"
  objectType = type(aVar)
</code></pre>

<p>Or more succinctly with the existential operator:</p>

<pre><code>objectType = type(aVar?)
</code></pre>

<p>As an alternative to type checking, you can often use duck typing and the CoffeeScript existential operator together to eliminating the need to resolve an object's type. For example, let's say we're pushing a value onto an array. We could say that, as long as the 'array like' object implements <code>push()</code>, we should treat it like an array:</p>

<p><span class="csscript"></span></p>

<pre><code>anArray?.push? aValue
</code></pre>

<p>If <code>anArray</code> is an object other than an array than the existential operator will ensure that <code>push()</code> is never called.</p>

<h2>Using instanceof</h2>

<p>JavaScript's <code>instanceof</code> keyword is nearly as broken as <code>typeof</code>. Ideally <code>instanceof</code> would compare the constructor of two object, returning a boolean if one was an instance of the other. However, in reality <code>instanceof</code> only works when comparing custom made objects. When it comes to comparing built-in types, it's as useless as <code>typeof</code>.</p>

<p><span class="csscript"></span></p>

<pre><code>new String("foo") instanceof String # true
"foo" instanceof String             # false
</code></pre>

<p>Additionally, <code>instanceof</code> also doesn't work when comparing object from different frames in the browser. In fact, <code>instanceof</code> only returns a correct result for custom made objects, such as CoffeeScript classes.</p>

<p><span class="csscript"></span></p>

<pre><code>class Parent
class Child extends Parent

child = new Child
child instanceof Child  # true
child instanceof Parent # true
</code></pre>

<p>Make sure you only use it for your own objects or, even better, stick clear of it.</p>

<h2>Using delete</h2>

<p>The <code>delete</code> keyword can only safely be used for removing properties inside objects.</p>

<p><span class="csscript"></span></p>

<pre><code>anObject = {one: 1, two: 2}
delete anObject.one
anObject.hasOwnProperty("one") # false
</code></pre>

<p>Any other use, such as deleting variables or function's won't work.</p>

<p><span class="csscript"></span></p>

<pre><code>aVar = 1
delete aVar
typeof Var # "integer"
</code></pre>

<p>It's rather peculiar behavior, but there you have it. If you want to remove a reference to a variable, just assign it to <code>null</code> instead.</p>

<p><span class="csscript"></span></p>

<pre><code>aVar = 1
aVar = null
</code></pre>

<h2>Using parseInt</h2>

<p>JavaScript's <code>parseInt()</code> function can return unexpected results if you pass a string to it without informing it of the proper base. For example:</p>

<pre><code># Returns 8, not 10!
parseInt('010') is 8
</code></pre>

<p>Always pass a base to the function to make it work correctly:</p>

<pre><code># Use base 10 for the correct result
parseInt('010', 10) is 10
</code></pre>

<p>This isn't something CoffeeScript can do for you; you'll just have to remember to always specify a base when using <code>parseInt()</code>.</p>

<h2>Strict mode</h2>

<p>Strict mode is a new feature of ECMAScript 5 that allows you to run a JavaScript program or function in a <em>strict</em> context. This strict context throws more exceptions and warnings than the normal context, giving developers some indication when they're straying from best practices, writing un-optimizable code or making common mistakes. In other words, strict mode reduces bugs, increases security, improves performance and eliminates some difficult to use language features. What's not to like?</p>

<p>Strict mode is currently supported in the following browsers:</p>

<ul>
<li>Chrome >= 13.0</li>
<li>Safari >= 5.0</li>
<li>Opera >= 12.0</li>
<li>Firefox >= 4.0</li>
<li>IE >= 10.0</li>
</ul>


<p>Having said that, strict mode is completely backwards compatible with older browsers. Programs using it should run fine in either a strict or normal context.</p>

<h3>Strict mode changes</h3>

<p>Most of the changes strict mode introduces pertain to JavaScript's syntax:</p>

<ul>
<li>Errors on duplicate property and function argument names</li>
<li>Errors on incorrect use of the <code>delete</code> operator</li>
<li>Access to <code>arguments.caller</code> &amp; <code>arguments.callee</code> throws an error (for performance reasons)</li>
<li>Using the <code>with</code> operator will raise a syntax error</li>
<li>Certain variables such as <code>undefined</code> are no longer writeable</li>
<li>Introduces additional reserved keywords, such as <code>implements</code>, <code>interface</code>, <code>let</code>, <code>package</code>, <code>private</code>, <code>protected</code>, <code>public</code>, <code>static</code>, and <code>yield</code></li>
</ul>


<p>However, strict mode also changes some runtime behavior:</p>

<ul>
<li>Global variables are explicit (<code>var</code> always required). The global value of <code>this</code> is <code>undefined</code>.</li>
<li><code>eval</code> can't introduce new variables into the local context</li>
<li>Function statements have to be defined before they're used (previously functions could be <a href="http://whereswalden.com/2011/01/24/new-es5-strict-mode-requirement-function-statements-not-at-top-level-of-a-program-or-function-are-prohibited/">defined anywhere</a>).</li>
<li><code>arguments</code> is immutable</li>
</ul>


<p>CoffeeScript already abides by a lot of strict mode's requirements, such as always using <code>var</code> when defining variables, but it's still very useful to enable strict mode in your CoffeeScript programs. Indeed, CoffeeScript is taking this a step further and in <a href="https://github.com/jashkenas/coffee-script/issues/1547">future versions</a> will check a program's compliance to strict mode at compile time.</p>

<h3>Strict mode usage</h3>

<p>All you need to do to enable strict checking is start your script or function with the following string:</p>

<p><span class="csscript"></span></p>

<pre><code>-&gt;
  "use strict"

  # ... your code ...
</code></pre>

<p>That's it, just the <code>'use strict'</code> string. Couldn't be simpler and it's completely backwards compatible. Let's take a look at strict mode in action. The following function will raise a syntax error in strict mode, but run fine in the usual mode:</p>

<p><span class="csscript"></span></p>

<pre><code>do -&gt;
  "use strict"
  console.log(arguments.callee)
</code></pre>

<p>Strict mode has removed access to <code>arguments.caller</code> &amp; <code>arguments.callee</code> as they're major performance hogs, and is now throwing syntax errors whenever they're used.</p>

<p>There's a particular gotcha you should look out for when using strict mode, namely creating global variables with <code>this</code>. The following example will throw a <code>TypeError</code> in strict mode, but run fine in a normal context, creating a global variable:</p>

<p><span class="csscript"></span></p>

<pre><code>do -&gt;
  "use strict"
  class @Spine
</code></pre>

<p>The reason behind this disparity is that in strict mode <code>this</code> is <code>undefined</code>, whereas normally it refers to the <code>window</code> object. The solution to this is to explicitly set global variables on the <code>window</code> object.</p>

<p><span class="csscript"></span></p>

<pre><code>do -&gt;
  "use strict"
  class window.Spine
</code></pre>

<p>Whilst I recommend enabling strict mode, but it's worth noting that strict mode doesn't enable any new features that aren't ready possible in JavaScript, and will actually slow down your code a bit by having the VM do more checks at runtime. You may want to develop with strict mode, and deploy to production without it.</p>

<h2>JavaScript Lint</h2>

<p><a href="http://www.javascriptlint.com/">JavaScript Lint</a> is a JavaScript code quality tool, and running your programs through it is a great way of improving code quality and best practices. The project was based on a similar tool called <a href="http://www.jslint.com">JSLint</a>. Check out JSLint's site for a <a href="http://www.jslint.com/lint.html">great list</a> of issues that it checks for, including global variables, missing semicolons and weak equality comparisons.</p>

<p>The good news is that CoffeeScript already 'lints' all of its output, so CoffeeScript generated JavaScript is already JavaScript Lint compatible. In fact, the <code>coffee</code> tool has support for a <code>--lint</code> option:</p>

<pre><code>coffee --lint index.coffee
  index.coffee: 0 error(s), 0 warning(s)
</code></pre>

  </div>
</div>
</body>
</html>